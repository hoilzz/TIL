# 연속합

N개의 정수(-1000~1000)가 있을 때, 연속된 숫자를 선택하여 가장 큰 합을 구하자.

## Solution

DP문제다.

`연속`이라는 것을 참고하자.

```
[1]번까지 연속된 합중 가장 큰것은?
[2]
[3]
...
- 기존에 연속된 값에 포함되기.
- 기존에 연속된 값이 작으니까 새로 연속 시작하기.
```

### fail

`D[i]`를 i번째 수로 끝나는 가장 큰 연속합이라고 하자.
`i`에게 가능한 경우는
	1. i-1번째 수의 연속합에 포함되기 : `D[i] + A[i]`
	2. 새로운 연속합 시작하기 : `A[i]`

두 값 중 어떤 값이 `D[i]`에 들어갈까?
`D[i] = max(D[i-1] + A[i], A[i])`



max로 구하는 것에 집착했다. 즉 내가 설정한 i번째 수로 끝나는 가장 큰 연속합이 아닌,
i번째 수로 끝났을 때 가장 큰 연속합은? 으로 정답을 구하려 했다.
이렇게 될 경우

```C
// sum은 연속합에 포함될 경우
//
for(i=0i<N;i++){

	// 연속합에 포함되는 경우
	if(sum[i-1] + a[i] > max[i-1])
	 	max[i] = sum[i-1] + a[i];

	// 새로운 연속합 시작
	else
	  //
		max[i] = a[i];

	sum[i] = sum[i-1] + a[i];
}
```

위와 같은 코드가 된다.
그렇게 될 경우, `sum` 배열이 새로 시작하더라도 max값만 바뀌고 sum은 계속 값이 누적된다. sum은 i번째 값까지 더한 결과값이 된다.
그러므로 새로운 연속합이 시작됐을 때,

```C
int sum[]; // i번째 idx에서 최대 연속합

for(int i=0; i<N; i++){
	// 새로운 연속합을 기본값으로 한다.
	sums[i] = nums[i];

	if(i==0) continue;
	if(sums[i-1] + nums[i] > nums[i]){
		sums[i] = sums[i-1] + nums[i];
	}
}
```

새로운 값이 시작됐더라도, 뒤 인덱스에 엄청 큰 값이 있어서 새로운 연속합과 기존 연속합읗 합쳐야한다면..?

- 우리는 매 index마다 새로운 연속합을 시작할지, 기존 연속합에 포함할지 판단했다.
- `이전인덱스의 최대 연속합 + 현재 선택된 값 < 현재 선택된 값` 을 통해 해결할 수 있었다.
