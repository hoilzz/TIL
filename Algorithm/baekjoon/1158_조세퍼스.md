# 조세퍼스

LL 문제라고 나와서 원형 리스트를 사용하였으나 런타임 에러..



### List로 풀기

```C
int main() {
    list <int> human(5001);
    list <int>::iterator humanPtr;

    int size, ploidNum, go = 0;

    scanf("%d %d", &size, &ploidNum);

    for (int i = 0; i < size; i++) {
        human.push_back(i + 1);
    }

    humanPtr = human.begin();

    printf("<");
    for (int i = 1; i <= size; i++) {
        while (go < ploidNum * i - 1) {
            humanPtr++;
            go += 1;
            if (humanPtr == human.end()) {
                humanPtr++;
            }
        }
        printf("%d", *humanPtr);
        if(i != size) printf(", ");

        human.erase(humanPtr);
    }
    printf(">\n");
}
```


### vector로 풀기

```C

#include <iostream>
#include <vector>
using namespace std;
vector <int> human;

int main()
{
    int size, hop, rmPos;
    scanf("%d %d", &size, &hop);
    rmPos = hop - 1;
    for (int i = 0; i < size; i++)
    {
        human.push_back(i + 1);
    }

    printf("<");
    while (1)
    {
        if (human.size() == 1)
        {
            printf("%d", human[rmPos]);
            break;
        }
        else{
            printf("%d, ", human[rmPos]);
        }


        human.erase(human.begin()+rmPos);
        rmPos = (rmPos + hop - 1) % human.size();
    }
    printf(">");
}


```

ㅊㅌㄴ
list는 `human[idx]`와 같은 random access가 안된다.

그러므로

```C
while (go < ploidNum * i - 1) {
	humanPtr++;
	go += 1;
	if (humanPtr == human.end()) {
		humanPtr++;
	}
}
```

이렇게 접근해야한다.

요소에 접근시 손실이 넘나 크다.. 그래서 벡터 쓰면 개선된다.
