# 쇠막대기

여러개 쇠막대기를 레이저로 절단할거다. 쇠막대기는 위아래로 겹쳐져서 쌓인다. 다음 배치 조건을 따른다.

- 쇠막대기는 자신보다 긴 쇠막대기 위에 놓인다.
  - 끝점이 겹치지 않게 완전히 포함되도록 놓는다.
- 긴 쇠막대기를 자르는 레이저 적어도 하나 존재한다.
- 레이저는 쇠막대기의 양 끝점과 겹치지 않는다.

- 레이저는 ()로 표현.
- 쇠막대기는 ()로 표현되는데, `()`는 무조건 레이저다.

이 때, 잘려진 쇠막대기 조각 총 개수를 구하시오.

## 내가 푼 방법

일단, 각 쇠막대기에 대한 점수 배열(`grade[]`)을 생성했다. 쇠막대기가 새로 생성될 때마다 (`(`를 만날 떄마다) 다음 검사를 한다.

1-a. 다음 인덱스 값이 `(`인지 확인한다. 맞다면,
2-a. `)`라면 lastIndex(int, 0으로 초기화)의 값에 + 1한다. 이 lastIndex는 현재 생성된 쇠막대기의 개수이자, 점수 배열에 대한 index역할을 한다. 
2-b. `(`라면 0부터 lastIndex까지 1씩 더한다. 

1-b. 아니면 `)`라면
2-a. 결과값에 grade[lastIndex] + 1 값을 추가한다. 그리고 lastIndex 값을 줄인다.

즉, grade[]에 각 쇠막대기에 대한 개수를 저장하며, 쇠막대기가 닫힐 때마다 index를 줄여가며 결과값에 쇠막대기 개수(grade[lastIndex])를 추가했다.

위 방식은 다음 코드가 된다.

```C
string stickList;
    int grade[100001] = {0,};
    int result = 0;
    int lastIndex = -1;
    
    cin>>stickList;
    
    for(int i = 0; stickList[i]; i+= 1) {
        if(stickList[i] == '(') {
            if(stickList[i+1]) {
                if(stickList[i+1] != ')') {
                    lastIndex += 1;
                } else {
                    for(int j = 0; j <= lastIndex; j++) {
                        grade[j] += 1;
                    }
                    i += 1;
                }
            }
        }
        else {
            result += grade[lastIndex] + 1;
            grade[lastIndex] = 0;
            lastIndex -= 1;
        }
    }
    
    cout<<result<<endl;
```

근데, 위와 같이 짜게되면 불필요한 grade[]배열을 생성해야한다. 다른 사람의 풀이 방법에서는 stack을 이용하여 더 간결하게 풀고 있다.

### 간결한 해결

```C
int pipe(const string& str) {
  stack<char> st;
  int result = 0;

  for(int i = 0; i<str.length(); i++) {
    if(str[i]=='(') st.push(str[i]);

    else {
      st.pop();

      if(str[i-1] == '(') {
        result += st.size();
      }

      else result += 1;
    }
  }
}
```

- `(`를 만나면 무조건 푸시한다.
  - 얘는 쇠막대기가 잘리는 개수 세기위한 기준 값.
- `)`를 만나면 무조건 pop한다.
  - 이 때, `str[i-1]`(원본 데이터)가 `(`라면 레이저로 판단하여, 결과값에 st.size() 즉, 스택에 쌓인 파이프 개수만큼 더한다.(스택에 쌓인 개수들이 레이저한테 잘리니까)
  - `)`면 걍 파이프가 닫히는거니까 result에 +1하고 종료한다. 

## summary

레이저인지 찾기 위해 굳이 i+1값을 비교할 필요 없이 )를 만날 때마다 레이저/쇠막대기 닫힘 인지 판단만 하면 된다. 왜냐면 둘 중에 하나의 값으로 잘린 쇠막대기 개수를 판단 할 수 있기 때문이다. 

또한, 나는 grade배열을 통해 잘린 쇠막대기 개수를 관리했는데 굳이 불필요한 공간을 생성할 필요가 없다. 쇠막대기가 잘린 개수만 구하면 되기 때문에 굳이 grade로 저장할 필요 없다. 왜냐하면 `잘리는 개수 = 레이저 개수 * 레이저보다 앞서 저장된 쇠막대기 개수 + 쇠막대기 닫히는 수(1)`이기 떄문이다. 이런식으로 답을 구하기 위한 미지수를 세워놓고 풀면 알고리즘을 풀 때 불필요한 식이 많이 제거될 수 있다. 

