---
layout: post
title: BOJ 1931 회의실 배정
description: "회의실 최대로 배정해보자"
tags:
  - "algorithm"
  - "greedy"
comments: true
share: true
date: 2017-5-11
---

# 회의실 배정

한 개의 회의실에 N개의 회의들에 대해 시간표를 만들려고 한다.
회의 시작시간과 끝시간이 주어진다.
회의가 겹치지 않으면서 최대로 회의를 하고자 한다.
단, 회의는 겹칠 수 없고, 회의가 끝남과 동시에 시작할 수 있다.

## Solution

처음에는 회의시간이 가장 짧고, 겹치지 않는 회의를 찾아야 겠다 생각했다.
결론은, 점수제를 생각했다.

```
점수 = (선택한 회의 시작시간 - 최근에 결정된 회의 종료시간) + (선택한 회의 종료시간 - 선택한 회의 시작시간)
```

내가 생각한 알고리즘은 다음과 같다.

1. `vector<pair <int, int>`로 시작,종료시간 입력을 받는다.
  - 값을 저장하면서 최대, 최소값을 빠르게 찾을 수 있는 priority_queue(pq)에 입력을 받는다.

2. 최근에 결정된 회의 종료시간 = 0으로 한다
  - 최근에 결정된 회의도 없고, 회의실 배정할 수 있는 시간은 0~24시 이기 때문이다.

3. 회의실이 결정되기 전까지 pq.top을 임시 비교 값(A)으로 사용한다.

4. 다음(B) pq.top() 값을 추출한다
5. A와 B가 시간대가 겹치면 A와 B의 점수를 비교한다
6. A와 B가 겹치지 않으면 A를 회의시간으로 책정한다.
7. 2~6번을 큐가 비어있을 때까지 반복한다.

```C
class CompareDist{
public:
    bool operator()(pair <int, int>n1, pair <int, int>n2){
        return n1.first>n2.first;
    }
};

priority_queue <pair<int,int>, vector<pair<int,int> >, CompareDist> pq2;

int main() {

    int len, result = 1;

    scanf("%d", &len);

    int from, to;

    for(int i = 0; i<len; i++) {
        scanf("%d %d", &from, &to);
        pq2.push(make_pair(from, to));
    }

    int currentFrom = pq2.top().first;
    int currentTo = pq2.top().second;
    int currentEnd = 0;

    int currentGrade = currentFrom - currentEnd + currentTo - currentFrom;

    pq2.pop();

    while(!pq2.empty()){
      int nextFrom = pq2.top().first;
      int nextTo   = pq2.top().second;
      int nextGrade = nextFrom - currentEnd + nextTo - nextFrom;
      pq2.pop();

      // 안겹치면...
      if(currentTo <= nextFrom) {
        currentEnd = currentTo;
        currentTo  = nextTo;
        currentGrade = nextFrom - currentEnd + nextTo - nextFrom;
        result+=1;
        // 현재 점수 계산하기
      }
      // 겹치면

      else {
        if(currentGrade > nextGrade){
          currentTo = nextTo;
          currentGrade = nextGrade;
        }
      }
    }
```

## 더 쉬운 방법

이 문제를 해결할 수 있는 방법들을 살펴보자.

1. 시작시간 기준으로 정렬하여 시작시간이 빠른 회의순으로 선택
  - 반례 : 늦게 시작하는 회의가 더 짧을 수 있다.
2. 가장 짧은 회의부터 선택하기
  - 반례 : 가장 짧은 회의가 중간 지점에 시작하여 종료한다.(하지만 2,3번째로 긴 회의시간과 겹친다.) 그리고 2,3번째로 긴 회의가 겹치지 않고 회의실을 2번 잡을 수 있다.

위 두 개로 해결할 수 없다.
이 문제를 해결하는 방법은 `그냥 가장 빨리 끝나는 회의` 선택하기다.
**가장 빨리 끝나는 회의를 선택할수록 선택할 수 있는 회의는 늘어난다**

```C
struct Meeting {
    int begin, end;
};
bool cmp(const Meeting &u, const Meeting &v) {
  if (u.end == v.end) {
    return u.begin < v.begin;
  } else {
    return u.end < v.end;
  }
}
int main() {
  int n;
  scanf("%d",&n);
  vector<Meeting> a(n);
  for (int i=0; i<n; i++) {
    scanf("%d %d",&a[i].begin,&a[i].end);
  }
  sort(a.begin(), a.end(), cmp);
  int now = 0;
  int ans =0 ;
  for (int i=0; i<a.size(); i++) {
    if (now <= a[i].begin) {
      now = a[i].end;
      ans += 1;
    }
  }
  printf("%d\n",ans);
  return 0;
}
```

코드가 더 간결해졌다.

## summary

반례는 [이 분 블로그](http://b.mystika.me/21)를 참고 했다. 내가 찾은 방법의 반례를 찾으면서 하면, 미련을 갖지 않고 빠르게 달느 방법을 찾을 수 있다. 반례를 찾는 습관을 들이자.
