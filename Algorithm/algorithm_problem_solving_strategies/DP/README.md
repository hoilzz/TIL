# Dynamic Programming

큰 문제를 작은 문제로 나눠서 푸는 알고리즘이다. 문제가 두 가지 속성을 만족해야 DP로 풀 수 있다.

1. Overlapping SubProblem(겹치는 작은문제)
2. Optimal SubStructure

예를 들어 피보나치 수를 보자.

- F0 = 0
- F1 = 1
- F(n) = F(n-1) + F(n-2) (n >= 2)

**큰 문제와 작은 문제는 상대적이다**

- 문제 : N번째 피보나치 수를 구하는 문제
- 작은 문제 : N-1번쨰 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

- 문제 : N-1번째 피보나치 수를 구하는 문제
- 작은 문제 : N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제

- 문제 : N-2번째 피보나치 수를 구하는 문제
- 작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제


**Overlapping SubProblem**

- 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
- 문제를 작은 문제로 쪼갤 수 있다.
- 문제의 정답을 작은 문제의 정답에서 구할 수 있다.

예를 들어, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면, 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다. 

**Optimal Substructure**

**문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.**

- 문제 : N번째 피보나치 수를 구하는 문제
- 작은 문제 : N-1번쨰 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

**문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.**

- 문제 : N-1번째 피보나치 수를 구하는 문제
- 작은 문제 : N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제

**문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.**

- 문제 : N-2번째 피보나치 수를 구하는 문제
- 작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제

Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다. 


## 특징

- DP에서 각 문제는 **한 번만 풀어야 한다.**
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때 마다 정답이 같다.
- 따라서, 정답을 한 번 구했으면 Memoization 기법을 통해 성능 최적화한다.