# VI 기술적 문제

## 1. 기술 문제 대비

문제와 답을 읽기만 하면 대수학 공부하는 것과 같다.

문제를 푸는 훈련을 해야 한다. `답을 외우는 것`은 도움이 되지 않는다.

### 문제 대비 훈련법

1. 직접 풀도록 노력하자.
	- `공간`과 `시간` 효율에 대해 반드시 생각하자.
	- 공간 효율을 희생해서 시간효율을 높일 수 있는지, 아니면 반대인지 생각하자.

2. 알고리즘 코드를 `종이`에 적어라.

3. 코드를 테스트 하라.
	- 역시 종이 위다. 기본 조건, 오류 발생 조건 등을 전부 테스트 해라.

4. 종이에 적은 코드를 컴퓨터로 옮겨라. 실수를 확인해라.

---

### 알아야 할 것들

기본적으로 알아야 할 것들이다.

1. 자료구조
	- 연결 리스트
	- 이진 트리
	- 트라이
	- 스택
	- 큐
	- Vector/arrayList
	- 해시 테이블

2. 알고리즘
	- BFS
	- DFS
	- 이진 탐색
	- 병합 정렬
	- 퀵 정렬
	- 트리에 대한 삽입/탐색

3. 개념
	- 비트 조작
	- 싱글톤 디자인
	- 팩토리 디자인
	- 메모리 (스택 VS 힙)
	- 재귀
	- O 표기법

이 주제에 대해 *안다는 것* 은

	- 사용법
	- 구현법 (밑바닥부터)
	- 공간과 시간 복잡도

에 대해 안다는 것이다.

*특히 해시 테이블이 매우 중요하다*

---


## 2. 기술 문제 대처 요령

### 기술 문제를 푸는 5단계

1. 문제의 모호한 부분에 대해 묻는다.

2. 알고리즘을 설계한다.
	- 처음에는 `brute-force` 알고리즘을 내놓고, 그 다음에 최적화 해도 된다.

3. 수도 코드를 작성해라. 실제 코드는 마지막에 작성한다

4. 적당한 속도로 코드를 작성하라
	- `자료구조`를 풍부히 활용하라
		+ 나이가 가장 어린 사람을 찾으라 라는 문제를 받았다면, `사람`을 나타내는 자료구조 정의할 수 있는지 고려해보자

5. 코드를 테스트하고 주의 깊게 오류를 교정하라
	- 코딩이 끝난 다음에 하는 대신, **코딩 도중에** 테스트를 하자.
	- 실수 발견시, 교정 작업에 들어가기 전에 `왜` 그 버그가 발생했는지 생각해라.
	- 가령, 함수가 어떤 값에 대해서 true 대신 false 반환할 때, 무작정 뒤집으면 당장 오류는 사라지지만 다른 새로운 문제 발생을 피할 수 없다.


## 3. 알고리즘 설계의 5가지 접근법

걍 많이 풀수록 어떤 접근법이 유용할지 알게 된다.

### I. 예증

특정한 사례들을 나열한다. 그 다음 `일반적 규칙`을 유도해 내자.

### II 패턴 매칭

풀어야할 알고리즘이 **어떤 문제와 유사한지** 살펴보자.

문제의 답을 수정하여, 지금 풀어야 하는 문제에 적용할 알고리즘을 개발하자.

> 정렬된 배열을 회전시켜 3 4 5 6 7 1 2 와 같은 배열을 얻었다.
> 배열 안에 중복된 값은 없다. 이 배열 내에서 최솟값은 어떻게 구할까
> - 배열 내의 최솟값을 찾아라
> - 배열 내의 특정 원소를 찾아라. (가령, 이진 탐색)
> 정렬 되어있고, 회전된 상태를 알고 있다.
> 그러니 오름 차순으로 정렬하다보면 초기화하고 다시 전진해야 한다.
> 최솟값 원소는 `초기화된` 지점에 있다.
> 배열의 중간원소 (MID)와 마지막 원소 (RIGHT)를 비교해보면 초기화 지점이 우측이라는 것을 알 수 있다.
> 따라서 이 접근법을, 마치 이진 탐색과 같이 배열을 반씩 나누어 가며 계속 적용해 나갈 수 있다.
> 종국에는 최솟값 원소(즉 초기화 지점)을 찾을 수 있다.


### III 단순화와 일반화

다단계 접근법으로 구현하는 것이다.

자료형이나 데이터 양과 같은 제약 조건을 변경한다. 그렇게 하면 문제를 `단순화`하는데 도움이 된다.

단순화된 버전의 문제를 풀고, 알고리즘이 구해지면 최종적으로 문제를 일반화하여, 구해진 알고리즘을 보다 복잡한 형태로 다듬어 간다.

> 인질범이 즐겨 찾는 몸값 쪽지는 잡지에서 단어를 오려 새로운 문장으로 조합하는 것이다.
잡지에서 특정한 몸값 쪽지(문자열로 표현된)를 마들어 낼 수 있는지 어떻게 알 수 있을까?
문제를 단순화 하기 위해 `단어를 오리는 것`이 아닌 `글자 하나`씩 오려 낸다고 해보자.
배열을 하나 만들어 글자의 출현 빈도를 세기만 하면 풀 수 있다.
배열의 각 원소는 글자 하나에 대응된다.
우선 몸값 쪽지 문자열 내의 각 문자 출현 횟수를 세고, 잡지를 훑어가며 그 모든 글자가 나오는지 보면 된다.
`글자의 출현 횟수를 세는 배열` 대신, `단어와 그 출현 횟수를 대응시켜 저장하는 해시테이블`을 만들면 된다.

### IV 초기 사례로부터 확장

특정한 종류의 문제에 적용하면 멋지다.

우선 초기 사례에 대해 문제를 푼다. (가령 n=1)

n=1의 답을 알고, n=2에 대해 풀어보자.

**결과적으로, N-1에 대한 답을 알면, N에 대한 답을 언제나 구할 수 있다.**

N이 3이나 4가 될 때까지, 이전 조건에 기초하여 답을 계산할 수 있을만한 `눈길을 끄는` 규칙이 발견되지 않을 수 있다.


> 문자열의 모든 순열을 계산하는 알고리즘을 설계하자.
모든 문자는 문자열 내에서 고유하다고 가정하자.
입력 문자열로 abcdefg가 주어졌다고 해보자.
```
Case "a" : {"a"}
Case "ab" : {"ab", "ba"}
Case "abc" : ?
```
> 이것이 최초로 만나게 되는 `눈길을 끄는` 경우다.
`P("ab")`에 대한 답을 안다면, 어떻게 `P("abc")`를 구할 수 있겠는가?
추가로 고려해야 할 문자가 `c` 이므로, 그냥 가능한 모든 지점에 `c`를 우겨 넣으면 된다.
```
P("abc") = c를 P("ab") 결과로 얻은 문자열의 가능한 모든 지점에 삽입
P("abc") = c를 {"ab", "ba"} 의 가능한 모든 지점에 삽입
P("abc") = merge({"cab", "acb", "abc"}, {"cba", "bca", "bac"})
```

이 패턴을 이용하여 일반적인 재귀 알고리즘 만들어보자.
문자열 `s(1)..s(n)`의 순열을 구하는 경우, 마지막 문자열은 잠시 제쳐놓고
`s(1)..s(n-1)`의 순열을 만든다.
순열 얻고 나면 각각의 모든 지점에 `s(n)`을 삽입한다.


### V 자료구조 브레인스토밍

이 방법은 지저분하지만, 통할 때도 자주 있다.

일반적인 자료구조를 차례대로 적용해보고 해결되는지 보면 된다.

> 난수 발생기로 만든 수들이 크기가 저절로 늘어나는 배열에 차례로 저장된다.
> 중간값을 추적하려면 어떻게 해야할까?
> - 연결리스트 : 아닐거다. 수를 정렬하거나 정렬된수에 접근하는데 취약하다.
> - 배열 : 그럴 수도 있다. 하지만 문제에서 이미 배열이라고 언급했다. 배열에 저장된 수를 정렬된 상태로 유지는 할 수 있지만 비용이 크다.
> - 이진 트리 : 가능하다. 순서 유지하는데 강점이 있다. 완전 이진 트리에서는 root가 중간 값이다. 하지만 조심하자. 원소가 짝수인 경우 바로 그 중간값은 사실 가운데 위치한 두 원소의 평균값이다.
> - 힙 : 기본적인 순서 관계, 그리고 최댓값 최솟값을 유지하기 정말 좋다. 정말 재미 있는 특성은 힙을 두 개 사용할 경우, 최대힙과 최소힙을 활용하여 루트에 가운데 수가 오도록 할 수 있다.
