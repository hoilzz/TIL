## 알고 준비를 위한 조언..

공부해야 할 주제의 다양성에 압도되서 배경지식을 늘리는 실수를 많이 한다.

그러나 복잡한 알고리즘 하나 더 아는 것보다 실제로 자신이 아는 것을 이용해
문제를 풀 수 있는 능력이 더 중요하다.

## 문제 해결 과정

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 프로그램으로 구현한다
5. 어떻게 풀었는지 보고, 개선할 방법이 있는지 찾아본다
 
### 1. 문제 읽고 이해하기

문제를 잘못 읽는 실수 때문이다. 조급한 마음에 문제를 곁눈질한 뒤 딸려오는 그림과 입출력 예제를 보고 문제가 원하는 것을 유추하기 십상이다.

### 2. 재정의와 추상화

자신이 다루기 쉬운 개념을 이용하여 문제를 자신의 언어로 풀어쓰는 것. `문제의 추상화`를 하자.
추상화란 현실 세계의 개념을 다루기 쉬운 수학적/전산학적 개념으로 옮겨 표현하는 과정이다.

문제의 본질을 어떤 방식으로 재구성하느냐에 따라 같은 일을 하는 프로그램이라도 전혀 다른 문제로 받아들일 수 있다.


### 3. 계획 세우기

문제를 어떻게 해결할지 계획을 세우자.
이 과정에서 문제를 어떤 방식으로 해결할지 결정하고, 사용할 `알고리즘`과 `자료구조`를 선택하자.

문제가 안떠오를 땐 가장 많은 고민을 하는데 2.3절에서 여러 전략을 보며 다시 살펴보자


### 4. 계획 검증하기

계획을 세웠다고 해서 곧장 키보드를 잡을 수 있는 건 아니다.
구현을 시작하기 전에 계획을 검증하는 과정을 거쳐야 한다.

### 5. 계획 수행하기

코드 짜기

### 6. 회고하기

한 번 푼 문제를 다시 본다고 해서 배우는 것이 있을까 하지만..
오히려 문제를 한 번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지 못하는 경우가 많다.

두번째로 문제를 풀 때는 더 효율적인 알고리즘을 찾거나
간결한 코드를 작성할 수 있고
같은 알고리즘을 유도할 수 있는 더 직관적인 방법을 찾을 수도 있다.

문제 해결 기술은 외워야 할 의사 코드도, 엄밀한 증명도 없는 추상적인 기술이다.
이들을 연마하기 위해 끊임없이 이 기술들을 어떻게 사용하는지 돌아보고 개선하자.

효과적으로 회고를 수행하는 가장 좋은 방법은 문제를 풀 때마다 `코드`와 함께 `자신의 경험`을 `기록`으로 남기는 것이다.

    - 어떤 방식으로 접근했는지
    - 문제의 해법을 차즌ㄴ 데 결정적이었던 깨달음은 무엇이었는지

이렇게 하면

    - 그 때 뭘 배웠는지 되새길 때 유용
    - 문제들 간의 공통으로 필요한 통찰들이 패턴화된다.

반대로 한 번에 맞추지 못한 경우 `오답 원인`을 적자.

또, `다른 사람의 코드`를 보는 것이다.
다른 사람의 코드를 이해하기 어렵지만, 다른 방식으로 문제를 해결하는 것을 보면
자신이 생각하지 못했던 통찰을 얻을 수도 있다.

## 문제를 풀지 못할 때

한 문제에 너무 매달리지 말자. 답 못찾으면 다른 사람의 소스나 풀이 참조하자.

단, 참조시 반드시 복기를 동반하자.

    - 자신이 문제 해결시 취했던 접근들을 되새기자 (왜 이 풀이를 떠올리지 못했는지 살피자)
    - 첨 보는 기술이라 한 번에 자신의 것으로 만들기 힘들지만 2,3번 하다 보면 비슷한 문제 봤을 때 해당 기법이 떠오르는 때가 있다.


## 2.3 문제 해결 전략

## 직관과 체계적인 접근

## 체계적인 접근을 위한 질문들

### 1. 비슷한 문제 풀어본적 있나?

형태가 비슷하거나 관련 무제를 풀어 본 적이 있다면 이전에 적용했던 방법과 비슷한 접근 방법을 사용할 거라고 예측할 수 있다. 프밍 대회 준비시 많은 문제를 풀어 보는 것의 중요한 이유가 바로 이것이다. 풀어 본 문제와 완전히 같은 문제를 만날 확률은 없다. 따라서 기존에 접했던 문제가 온전히 경험이 되려면 그 원리를 완전히 이해하고 변형할 수 있어야 한다.

> 예를 들어, 철도망 위에서 두 도시를 잇는 가장 짧은 경로를 찾는 문제를 풀었다.
최단 경로 문제는 잘 알려진 문제다. 그리고 이 문제를 해결하는 수많은 표준 알고리즘이 있다. 따라서 해당 코드를 외우고 나면 최단 거래 문제들을 다 풀 수 있을거라고 생각한다. 하지만 이런 변형 문제는?
- 한 도시를 두 번 방문하지 않으면서 가장 긴 경로를 찾는 문제
- 기차를 네 번 이하로 갈아타면서 가장 짧은 경로를 찾는 문제
- 역 간 운행 거리 중 가장 긴 구간이 가장 짧은 경로를 찾는 문제

이들을 구분하려면 최단 경로 알고리즘을 단순히 알고 있는 것에 멈추지 않고 그 `동작 과정`과 `원리`를 완전히 이해하고 있어야 한다. 꼭 형태가 비슷하지 않더라도 문제의 목표가 같은 경우 이런 사례에 속한다.

경우의 수를 계산하는 문제들은 거의 DP로 해결할 수 있다.

**문제의 `목적`을 보고 적절한 접근 방법을 선택하기 위해**

	- 어떤 문제가 최적화 문제인지
	- 경우의 수를 구하는 문제 인지
	- 검색 문제 인지

**분류하는 방법을 익히고, 각 알고리즘이 어느 경우에 사용될 수 있는지 체계적으로 공부해야 한다.**


### 2. 단순한 방법에서 시작할 수 있을까?

aka 무식하게 풀 수 있을까
다시 말해, **시간과 공간 제약을 생각하지 않고 문제를 해결할 수 있는 단순한 알고리즘**을 만드는 것이다.
이 전략의 일차적 목표는 간단하게 풀 수 있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 실수를 예방하는 것이다.

이 방법이 유용한 이유는 **효율적인 알고리즘이라도 단순한 알고리즘을 기반으로 구성된 경우**가 많기 때문이다.
이런 경우
	- **좀 더 효율적인 자료구조를 사용**하거나,
	- 계산 과정에서 같은 정보를 두 번 중복으로 계산하지 않는 등

`최적화`를 적용하여 충분히 빨라질 때까지 알고리즘을 개선하는 식으로 문제를 풀 수 있다.

충분히 빨라질 때까지 알고리즘을 개선하는 식으로 문제를 풀 수 있다.
이 문제 해결 방법은 강력하면서도 사고 과정의 큰 도약이 필요하지 않으므로 어려운 문제 접했을 때 시도해볼 수 있다.

점진적인 개선을 통해 문제를 풀 수 없더라도 단순한 방법은 알고리즘 효율성의 기준선을 정해주는 효과가 있기 때문이다.
어느 정도 시간에 동작하는 알고리즘을 알고 있어야 다른 알고리즘이 그에 비해 얼마나 개선되었는지 알 수 있다.

> 예제를 풀어보자.
N개의 사탕을 세 명의 어린이에게 공평하게 나눠주려고 한다. 그 기준은 받은 사탕의 총 무게가 가장 무거운 어린이와 가장 가벼운 어린이 간의 차이로 하자. 사탕의 무게는 모두 20이하의 정수이다.

1. 이 문제를 푸는 가장 단순한 방법은 사탕을 나눠 주는 모든 방법을 하나씩 만들어 보는 것이다.
	- 각 사탕마다 셋 중 어느 어린에게 줄지 결정한다면 `3^N`, 최대 205조 개의 경우의 수가 있다.

2. 중요한 것은 `사탕의 분배 방식`이 아닌 `각 어린이가 받은 사탕 무게의 총 합` 이다.
	- 205조 개의 경우의 수 중 어린이의 사탕 총량이 같은 경우를 하나로 합치면 `(NX20)^3 = 2억` 이다.
	- 이 상태 공간을 `BFS`로 탐색하면 답을 찾을 수 있다. 하지만 답을 찾기엔 아직 경우의 수가 크다.
	- 2억개의 경우의 수를 메모리에 저장할 수 없다.

3. 위 방법을 더 최적화 하는 방법은 이 문제의 답이 최대 얼마일지 생각해 보는 것.
	- 사탕 총량의 최대치와 최소치가 20이상 차이난다고 가정해보자.
	- 사탕의 최대 무게는 20이고, 사탕을 가장 많이 받은 어린이가 가장 적게 받은 어린이에게 사탕 하나 줘도 역전되지 않는다. 따라서 차이가 20 이상인 경우는 최적의 답이 될 수 없다. 넉넉잡아도 사탕 가장 많이 받은 어린이가 200 넘게 사탕을 받는 경우는 무시해도 된다. 이렇게 하면 경우의 수는 `220^3` 대략 1000만으로 줄어든다.

4. 이 정도면 된거 같지만 문제를 푸는 더 빠른 방법이 있다.
	- 세 어린이 중 누가 가장 사탕을 적게 받고, 누가 가장 많이 받는지는 중요하지 않다.
	- 세 어린이의 사탕 총량이 `180,190,200` 이건 `200,190,180`이건 답은 똑같다.
	- 따라서 사탕의 총량이 오름차순으로 정렬되어 있는 경우만을 탐색한다. 이렇게 하면 경우의 수는 `1/6`으로 줄어든다.


### 3. 내가 문제를 푸는 과정을 수식화 할 수 있을까?

새로운 방향에서 접근해야 풀리는 문제들이 있다.
손으로 여러 간단한 입력, 예를 들어 `문제에 주어진 예제 입력을 직접 해결하기`로 문제를 푸는 것이다.
**자신이 문제를 해결한 과정을 공식화**해서 답을 만드는 알고리즘을 만드는 경우가 있다.

손으로 문제를 풀어 보는 습관은 어떻게 문제를 풀어야 할지 감이 올 때도 유용하다.

### 4. 문제 단순화하기

좀더 쉬운 변형판을 먼저 풀어보기.

	- 문제의 제약 조건 없애기
	- 계산해야 하는 변수의 수 줄이기
	- 다차원의 문제를 1차원으로 줄이기

이 때 단순화된 문제의 해법이 원래 문제의 해법에 대한 직관을 제공할 수도 있다.

### 5. 그림 그리기

문제에 대한 직관을 얻을 수 있는 또 다른 방법은 그림을 그려 보는 것이다.
많은 사람의 사고 체계는 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들인다.

> 2개의 정수쌍을 다루는 문제가 있다면, 이 정수 쌍을 2차원 평면 상의 좌표로 그려볼 수 있다.
또는 직선 상의 구간들로 그려볼 수 있다.

### 6. 수식 표현하기

평문으로 쓰여있는 ㅁ누제를 수식으로 표현하기

### 7. 문제 분해하기

더 다루기 쉬운 형태로 문제를 변형하기.

이 기술의 대표적인 예로 `문제의 제약 조건을 분해`하는 방법이 있다. 이 방법은 문제에 주어진 복잡한 조건을 더 단순한 형태를 갖는 조건의 집합으로 분해한다.

> 달리기 경주에 N명의 육상 선수가 참여한다. 이 선수들의 과거 기록들을 수집해 각 선수의 최고 기록 `best[]`와 최악 기록 `worst[]`를 찾았다. 이 가정을 이용해 다음과 같은 형태의 신문기사 M개가 나왔다.
1. 선수 i는 선수 j에게 반드시 패배함
2. 선수 i와 선수 j가 서로 상대에게 이길 가능성이 있다.



### 8. 뒤에서부터 생각하기

### 9. 순서 강제하기

### 10. 특정 형태의 답만 고려하기
