# 3.1 도입 : 코딩의 중요성

코딩의 중요성을 간과한다.
프밍 대회에서 대충 책에서 베낀 알고리즘을 끼워맞춰 스파게티 코드를 짜낸다고 오해한다.

프밍 대회에서 좋은 성적을 올리기 위해 당장 빨리 코드 작성하기 보다 읽기 쉬운 코드를 작성하는 것이다.
복잡하고 읽기 어려운 코드는 디버깅도 어렵고 한번에 작성하기도 어렵다.
실제로 프밍 대회 상위 입상자들은 코드에서 시간에 쫓겨 작성한 흔적을 찾기란 쉽지 않다.

이 장에서는 코딩과 디버깅에 관한 노하우와 프밍 대회에서 자주하는 실수들에 대해 알아보자.

# 3.2 좋은 코드를 짜기 위한 원칙

## 간결한 코드 작성하기

코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄어든다. 또한 디버깅도 쉽다.

하지만 프밍 대회에서는 경우에 따라 일반적인 경우보다 한발짝 더 나아간 방법들을 사용할 수 있다.
이런 방법은 일반적인 프로그램에서는 권장하지 않는다.
하지만 작성하는 프로그램이 짧고 그 용도가 제한된 프밍 대회 특성상 잘 가려 사용하면 유용하다.

그 대표적인 예가 `전역변수의 광범위한 사용`이다.
프밍 대회에서는 전역 변수를 많이 사용하면 구조가 매우 단순해진다.
또한, 변수를 읽고 쓰는 부분이 명확해진다.

이외에 프밍 대회에서만 사용해야하는 `흑마법` 중 하나는 C/C++ 매크로를 이용해 간결한 코드 작성하는 것이다.
반복문처럼 자주 타이핑 하는 코드의 일부를 C++ 매크로로 표현한다.
예를 들어, **정렬되지 않은 정수 배열에 중복 원소가 존재하는지 확인하는 함수**가 있다고 하자.

```C
bool hasDuplicate(const vector<int>& array){
	for(int i = 0; i < array.size(); ++i)
		for(int j = 0; j< i; ++j)
			if(array[i] == array[j]) return true;
	return false;
}
```

매크로 사용시 코드는

```C
#define FOR(i,n) for(int i = 0; i < (n); ++i)

bool hasDuplicate(const vector<int>& array){
	FOR(i, array.size())
		FOR(j,i)
			if(array[i] == array[j]) return true;
	return false;
}
```

이런 코드는 범죄같이 느껴지지만 다음과 같은 실수를 피할 수 있다.

```C
for (int i = 0; i < array.size(); ++i)
	for(int j = 0; j < i; ++i) // ++j 여야 함!
```

## 적극적으로 코드 재사용하기

- 코드를 모듈화하기
- 같은 코드가 반복되면 `함수`나 `클래스`로 분리해 재사용하기

같은 코드가 세 번 이상 등장하면 해당 코드를 함수로 분리해 재사용하는 기본 원칙을 만들면 좋다.
물론 대회에서는 이렇게 코드를 고칠 여유가 없다. 그러나 시간이 없다고 해서 더 알기 쉽게 고치는 데 주저해서는 안된다.
당장은 차이가 없더라도 항상 코드를 깔끔하게 작성하고 유지하는데 신경을 쓰다보면 스스로가 그와 같은 코드에 익숙해진다.
간결한 코드에 익숙해진 사람은 다음 번에도 좀 더 간결하게 코딩할 수 있게 된다.


## 표준 라이브러리 공부하기

처음 프밍 대회 나오는 사람이 실수 하는 것은 큐, 스택, 자료 구조, 정렬 등의 기초적 알고리즘을 직접 작성하는 것이다.
시간 제한이 있는 프밍 대회에서 모든 코드를 직접 작성하는 것은 시간 낭비다.

언어의 문자열, 동적 배열, 스택, 큐, 리스트, 사전 등의 자료 구조 그리고 정렬 등의 표준 알고리즘 구현 사용법을 잘 알아두자.

## 항상 같은 형태로 프로그램 작성하기

프밍 대회에서는 여러 종류의 코드를 반복적으로 짜게 된다.
이분법, 그래프의 너비 우선 탐색, 2차원 평면의 점을 표현하는 자료구조, 두 개의 구간이 서로 겹치는지 확인하는 함수 등이 좋은 예다.
이들은 다른 문제를 해결하는 도구로도 이용되기 때문에 자주 작성하게 된다.

그래서 같은 코드를 다양한 방식으로 짜본다.
while문을 쓰던 자리에 do-while문을 사용해 보기도 하고, 2차원 배열의 크기를 세로 크기, 가로 크기 순으로 전달하다가
가로 크기, 세로 크기 순으로 전달하기도 한다.

처음에는 이 과정이 자신이 가장 알아보기 쉬운 코드를 작성하는데 도움이 되기 때문에 권장한다.
하지만 시간이 지남에 따라 이것은 실수의 원인이 되어간다.
코드 검증은 쉬운일이 아니고, 검증하는 여유를 부리기 힘들다.
그래서 자주 작성하는 알고리즘 코드에 대해서는 검증된 코드를 작성하고 이것만을 꾸준히 사용하자.
그래야 도구가 아닌 문제에 집중할 수 있다.

## 일관적이고 명료한 명명법 사용하기

```C
int a[30][30], i, j, p[100], k=0, l=-1;
```
실무에서는 완전 낙제감이고, 프밍 대회도 마찬가지다.
모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이자.

```C
bool judge(int y, int x, in cy, int cx, int cr);

bool isInsideCircle(...)
```

2차원 평면 상에 한 개의 점과 원이 주어졌을 때
점이 원 안에 포함되는지 여부를 반환하는 함수 이름을 아래와 같이 바꿔서 명료하게 해보자.


## 모든 자료를 정규화해서 저장하기

유리수를 표현하는 클래스 `Fraction`을 작성해보자.
이 때 입력받는 유리수를 항상 약분해 기약 분수로 표현하는 것이 좋다.
그렇지 않으면 `9/6`을 표현하는 변수와 `3/2`를 표현하는 변수가 따로 존재하게 된다.
이런식으로 자료가 두 개 이상의 표현을 가지게 되면 미묘한 버그를 만들기 쉽다.
각각의 문자열 표현이 달라지고, 해시 값이 달라지는 등의 문제가 있기 때문이다.

## 코드와 데이터를 분리하기

날짜를 다루는 프로그램 작성시, 날짜 출력할 때 월을 숫자가 아니라 영문 이름으로 출력해야 한다고 치자.
프밍 처음 배운 사람이 하는 큰실수는 다음과 같은 12줄 짜리 함수를 짜는 것이다

```C
string getMonthName(int month){
	if(month == 1) return "Januanry";
	if(month == 2) return "Februray";
	...
	return "December"
}
```

경험이 생기면 이런 코드 피하게 된다.
**코드의 논리와 상관 없는 데이터는 가능한 분리하는 것이 좋다.**
각 월의 영어 이름을 다음과 같은 테이블로 만들 수 있다.

```C
const string monthName[] = {
	"Jan", "Feb", "Mar", ... ,"Nov", "Dev"
}
```

이 기법의 좋은 예로 체스 같은 보드게임이 있다.
말들의 움직임을 다루는 문제를 풀 경우, 각 말이 움직일 수 있는 위치를 프로그램으로 작성하는 대신
움직일 수 있는 상대 좌표를 배열에 저장해 두면 좋다.

```C
const int knightDx[8] = {2,2,-2,-2,1,1,-1,-1};
const int knightDy[8] = {1,-1,1,-1,2,2,2,-2};
```

## 3.3 자주 하는 실수

### 산술 오버플로

변수의 표현 범위를 벗어나는 값을 사용. (복잡하니까 3.5에서 다시 다룰께)

### 배열 범위 밖 원소에 접근

C/C++은 배열의 원소에 접근시, 해당 인덱스가 배열 범위 안에 있는지 확인해 주지 않는다.
런타임 오류 내고 종료하면 배열 범위 밖에 있다는거 알 수 있지만,
오류도 나지 않으면서 틀린 답 내놓는 경우도 있다.

```C
int array[10], t
```

이 때 변수 array와 t가 메모리 상에 연속해서 위치하게 됐다고 해보자.
실수로 `array[10]` 위치에 값을 대입하면, 엉뚱하게도 t에 있던 값이 덮어 씌워진다.

#### 이런 실수를 예방하는 가장 좋은 방법

배열 크기 정할 때 계산 신중히 하기

### 일관되지 않은 범위 표현 방식 사용하기

여러가지의 범위 표현 방식을 섞어 쓰면 배열의 잘못된 위치를 참조하여 오류 발생 하기 쉽다.

`[lo,hi)` lo, lo+1, ..., hi-2, hi-1 을 포함한다.

- n개의 원소를 갖는 `배열` a의 첫 번째 원소는 `a[0]`이다. 마지막 원소는 `a[n-1]`이다.

- C++ STL 에서는 반복자로 범위를 표현할 때, 첫 원소를 가리키는 반복자와 마지막 원소 다음 위치를 가리키는 반복자를 사용한다.
	- 예를 들어 STL 자료 구조에서 모든 원소를 갖는 범위는 `begin()`, `end()`로 표현한다.
	- `begin` : 첫 번째 원소, `end` : 마지막 원소가 아닌 마지막 원소 다음의 가상 원소


---

### off-by-one 오류

계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류다.

100미터 담장에 10미터 간격으로 울타리 기둥 세울 때, 기둥은 10개가 아닌 11개가 필요.

정수배열 `A[]`에서 `A[i]`부터 `A[j]`까지의 평균 구할 때 합을 얼마로 나눌까?

`j-i` 가 아닌 `j-i+1`이다.

이런 오류를 방지 하기 위해, **최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서** 코드 짜야 한다.


### 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명에서 낸 오타는 컴파일러가 잡아준다.
하지만 상수를  잘못 입력해서 오답 처리 되는 경우가 있다.

- 64비트 저수형에 들어갈 상수를 쓰면서 해당 상수가 64비트라고 지정하지 않는 실수.
	- C++ 의 경우 정수형 상수 뒤에 LL을 붙이지 않으면 해당 상수는 32비트가 된다. .

### 스택 오버플로

call stack 이 오버플로 해서 프로그램이 강제 종료 되는것 또한 흔히 하는 실수다.
재귀 호출의 깊이가 너무 깊어져서 온다.

스택 최대 크기는 컴파일이나 실행시에 설정 가능하다.
**C++ 의 경우 지역 변수로 선언한 배열이나 클래스 인스턴스가 `스택 메모리`를 사용한다.**
**그러므로 배열 등 큰 지역 변수를 스택에 잡으면 재귀 호출이 몇 번 없어도 곧장 스택 오버플로가 난다.**
**때문에 참가자들은 자동으로 `힙`에 메모리를 할당하는 STL 컨테이너나 전역 변수를 사용한다.**


### 잘못된 비교 함수 작성

정수의 집합들을 다루는 프로그램에 정수의 집합을 저장하는 `IntergerSet` 클래스가 있다고 하자.
이 프로그램이 하는 일 중 하나는 `vector<IntegerSet>`에 담긴 집합들을 순서대로 처리하는 것이다.

집합 A가 B의 진부분집합이라면 A는 항상 B보다 먼저 처리되어야 한다.


### 최소, 최대 예외 잘못 다루기

예외란 말 그대로 우리가 예상한 입력의 규칙에 들어맞지 않는 모든 입력이다.

가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들은 생각 외로 많으므로,
코드를 짤 때 `가장 작은 입력`과 `가장 큰 입력`에 대해 제대로 동작하는지 생각해보면 오류를 잡을 수 있는 경우가 있다.



### 연산자 우선순위 잘못 쓰기

시프트 연산자나 비트 단위 연산자들의 우선순위는 종종 헷갈린다. 예를 들어



## Summary

### 좋은 코드 짜기

- **코드가 짧을수록** 버그,오타가 줄어들고 디버깅 쉽다.
- `전역변수`를 사용하자.
- C/C++ 매크로를 이용해 간결한 코드를 작성하자.

- 코드를 모듈화하자
- 같은 코드가 반복되면 `함수`나 `클래스`로 분리해서 재사용하자.
	- 대회에서는 이렇게 짤 시간이 없겠지만, 시간이 없다고 알기 쉽게 고치는 데 주저해서는 안된다.

- 표준 라이브러리 공부하자.
	- 큐, 스택, 자료 구조, 정렬 등 기초적 알고리즘 직접 작성하지 말고 이용하자

- 항상 같은 형태로 프로그램 작성하자.

- **`코드`와 `데이터`를 분리하자**


### 자주 하는 실수

1. 산술 오버플로 : 변수의 표현 범위 벗어나는 값 사용(3.5 다시 설명)
2. 배열 범위 밖 원소에 접근 : 컴파일러가 해당 인덱스가 범위 안에 있는지 확인 안해줌.
3. 일관되지 않은 범위 표현 방식 사용하기
	- STL 자료 구조에서 `end()`는 마지막 원소가 아닌 마지막원소 다음 가상 원소

4. 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드 : `최소 입력` 주어졌을 떄 이 코드가 어떻게 동작하는지 되새겨 보자.

5. 컴파일러가 잡지 못하는 상수 오타
	- 64비트 정수형에 들어갈 상수는 C++ 의 경우 상수 뒤에 `LL`을 붙여야 한다

6. `스택 오버플로`
	- call stack 이 오버플로 해서 프로그램이 강제 종료 되는 것 또한 흔히 하는 실수다. 재귀 호출의 깊이가 너무 깊어져서 온다.
	- C++의 경우 지역 변수로 선언한 배열 및 클래스 인스턴스는 `스택 메모리`를 사용, 그러므로 배열 등 큰 지역 변수를 스택에 잡으면 재귀 호출 몇 번 없어도 곧장 스택오버플로 난다.
	- 참가자들은 자동으로 `힙`에 메모리를 할당하는 STL 컨테이너가 전역변수 많이 사용
