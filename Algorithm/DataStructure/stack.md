# stack

목록의 한쪽 끝에서만 자료를 넣고 뺄 수 있는, LIFO인 자료구조다. (접시가 쌓여있는 걸 생각하자.)

## 응용

**재귀함수 호출**이 모두 스택형태로 되어있다. 위 코드를 보면 함수 A 호출 중에 B를 호출, B 실행 중에 C를 호출한다. 함수 실행 결과를 반환하는 과정은 호출 순서의 반대다.

각 함수의 메모리 주소 값이 스택에 저장되어있고, 스택은 LIFO이기 때문에 결과의 반환 순서는 호출 결과의 반대다.

### 응용1: 사칙연산

숫자와 숫자 사이에 연산자를 넣어 표기하는 방법을 중위 표기법이라고 한다. 아래 예제를 보자.

> 2 + 3

중위표기법은 괄호 연산자가 필요없는 전위 표기법 (+ 2 3), 후위 표기법(2 3 +)과는 다르게 괄호가 매우 중요하다. 연산 순서를 명시적으로 나타내야 할 때가 있기 때문이다. 예를 들어 아래 표기법은 2와 3을 더하는 연산이 먼저 수행된다.

> (2 + 3) x 4

후위 표기법은 아래와 같다.

> 2 3 + 4 x

중위표기법은 사람에겐 편하지만 컴퓨터로는 구문 분석하기 어렵다. 이 때문에 연산자를 연산 대상의 뒤에 쓰는 후위표기법이 쓰인다. 후위표기법은 괄호가 없고 수식 계산시 식을 앞에서 읽어 나가면서 차례로 처리한다. 이 때 스택이 유용하게 쓰인다.

컴퓨터가 중위표기법으로 표현된 수식을 계산하는 과정은 다음 두 단계로 볼 수 있다.

1. 전위표기법으로 표현된 수식을 후위표기법으로 변환
2. 후위표기법으로 표현된 수식을 계산

#### 1번을 한다고 해보자

> A + B x C + (D x E + F) x G
> === ABC x + DE x F + G x +

- 계산 대상 숫자가 나오면 result 변수에 저장한다
- 왼쪽 괄호가 나오면 스택에 저장한다
- 오른쪽 괄호가 나오면 스택에 이미 저장된 왼쪽 괄호 사이에 있는 모든 요소를 팝한다.
- 연산자가 나오면 해당 연산자보다 연산 우선순위가 낮거나 같은 연산자가 나올 때까지 팝을 반복한다.
  - 팝된 요소들은 result에 저장하고, 해당 연산자를 스택에 푸쉬한다.
- 식의 끝을 만나면 스택에 있는 모든 요소를 팝한다.

#### 2번을 한다고 해보자

- 숫자를 만나면 스택에 푸쉬한다
- 연산자를 만나면 2개 요소를 팝을 하고, 두 요소를 연산하고, 그 값을 다시 푸쉬한다.


