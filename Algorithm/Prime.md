# Prime

- 소수 : 약수가 1과 자신밖에 없는 수
- N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지면 된다.
  - N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문
- `N = a x b`로 나타낼 수 있다. a가 작을 수록 b는 크다.
- 가능한 a중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않는다.


## 1 O(N)

소수를 구해보자.

```C

bool prime(int x) {
  if (x < 2) {
    return false;
  }

  for (int i = 0; i <= x/2; i++) {
    if (x % i == 0) {
      return false;
    }
  }
  return true;
}

```

- 만약 x가 24일 경우
  - `1 2 3 4 / 6 8 12 24` 약수가 발생
  - 이 때 `/` 앞부분이 `i` 역할, 즉 구하려는 값의 1/2 안에서 소수인지 아닌지 판별 가능
  - 그렇기 때문에 `i <= x/2` 만 수행해도 된다.

## O(루트 n)

- N이 소수가 되려면, 2보다 크거나 같고, `루트 N` 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
  - N이 소수가 아니라면 `N = a x b` 로 나타낼 수 있다. (`a <= b`)
- `a > b` 라면 두 수를 바꿔서 항상 `a <= b` 로 만들 수 있다.
- 두 수 a,b 의 차이가 가장 작은 경우는 `루트 N` 이다.


```C
bool prime(int x) {
  if (x < 2) {
    return false;
  }
  for (int i = 0; i*i < N; i++) {
    if(x % i == 0) {
      return false;
    }
  }
  return true;
}
```

- 컴퓨터에서 실수는 근사값을 나타내기 때문에, 루트 N과 같은 경우 위와 같이 표기


## summary
- 어떤 수 N이 소수인지 아닌지 알아내는데 `O(루트 N)` 이다.
- N이 1억인 경우 `루트 N = 10000`
- 그럼 1부터 1,000,000 까지 소수 구하는데 걸리는 시간 복잡도는?
  - 각 수에 대해 `O(루트 N)`
  - 총 N개 이기 때문에 `O(N 루트 N)`
  - 1,000,000 * 1,000 = 1,000,000,000 = 10억 = 10초
  - 너무 오래걸린다

## 에라토스테네스의 체
- 1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 **`에라토스테네스 체`** 를 이용

1. 2부터 N까지 모든 수 써놓는다
2. 아직 지워지지 않은 수 중 가장 작은 수 찾는다
3. 그 수를 지우고 소수로 저장
4. 이제 그 수의 배수를 모두 지운다

```C
int p[100];
    int numOfPrime = 0;
    bool num[101] = {false};

    for (int i = 2; i <= 100; i++){
        if (num[i] == false) {
            p[numOfPrime++] = i;
            for (int j = i*2; j<=100; j+=i) {
                num[j] = true;
            }
        }
    }

    // 소수의 개수
    printf("\n%d\n", numOfPrime);

    // 1~100 사이 중 소수 출력
    for (int i = 0; i< numOfPrime; i++) {
        printf("%d ", p[i]);
    }
```
