# Graph

- 정점(Node, vertex)
- 간선(Edge) 
- G = (V,E)로 나타낸다.
- 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클

그래프는 크게 3가지가 있다.

1. 단방향 그래프
2. 양방향 그래프
3. 두 정점 사이에 간선 여러개인 그래프
4. 가중치를 가진 그래프

## 그래프의 표현

```
6 8
1 2
1 5
2 3
2 4
2 5
5 4
4 3
4 6
```

첫째 줄에는 정점과 간선 개수.
둘째 줄 부터는 간선의 정보

### 인접행렬

정점의 개수를 N이라고 했을 때, `N X N`크기의 이차원 배열을 이용한다.
`A[i][j] = 1` (i->j 간선 있는 경우), 없는 경우 `= 0`

| | 1 | 2 | 3 | 4 | 5 | 6 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|0|0|1|0|
|2|1|0||1|1|1|0|
|3|0|1|0|1|0|0|
|4|0|1|1|0|1|1|
|5|1|1|0|1|0|0|
|6|0|0|0|1|0|0|

```C
int graph[10][10];

int n,m;
cin>>n>>m;

for(int i = 0; i<m; i++){
  int u, v;

  // 가중치가 없는 경우
  scanf("%d %d", &u, &v);
  a[u][v] = a[v][u] = 1;

  // 가중치가 있는 경우
  // scanf("%d %d %d", &u, &v, &w);
  // a[u][v] = a[v][u] = w;
}
```

### 인접리스트

Linked List(LL)를 이용하여 구현한다.
`A[i] = i`와 연결된 정점을 LL로 포함하고 있다. 

```
A[1] : [2,5]
A[2] : [1,3,4,5}]
A[3] : [2,4]
A[4] : [3,5,2,6]
A[5] : [1,2,4]
A[6] : [4]
```

LL은 구현하기에 시간이 오래걸린다. 주로 **vector와 같이 가변형 배열을 이용하여 구현**

```C
vector<vector<int>> graph(n+1);
// vector<pair<int>> a[10];
for(int i = 0; i<m; i++){
  int u, v;
  scanf("%d %d", &u, &v);
  a[u].push_back(v); a[v].push_back(u);
  // a[u].push_back(make_pair(v,w)); a[v].push_back(make_pair(u,w))
}
```

공간 복잡도
- 인접 행렬 : `O(V^2)`
- 인접 리스트 : `O(E)`

## 탐색

BFS, DFS를 이용하면 된다. 다음 챕터에서 알아보자.