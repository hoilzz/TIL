# 6. 무식하게 풀기

## 도입

프밍 대회에서 **가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것**이다. 우아한 답안을 만들고 싶어서, 바로 앞에 보이는 쉽고 간단한 틀릴 가능성이 낮은 답안을 간과하기 쉽다. 이런 실수를 피하기 위해 문제를 만주하고 나면 `무식하게 풀 수 있을까?`를 먼저 스스로에게 물어보자.

`무식하게 푼다(brute force)`는 컴퓨터의 빠른 계산을 이용해 가능한 경우의 수를 일일이 나열하며 답을 찾는 방법이다. 예를 들어, 두 점 사이의 최단 경로를 찾는 문제라면 두 점 사이의 경로를 모두 만들어서 그 중 가장 짧은 것을 찾는 방법이 있다. 자원을 분배할 수 있는 경우의 수를 센다면 한가지씩 분배 방법을 전부 만들어 보는 `무식한` 알고리즘의 좋은 예라고 할 수 있다.

이렇게 가능한 방법을 전부 만들어 보는 알고리즘을 가리켜 완전 탐색(brute-force search, exhaustive search)라고 부른다. 예를 들어, 10명의 학생을 한 줄로 세워보자. 서로 사이가 안좋은 학생은 붙여 놓으면 안된다. 그래서 이들을 서로 떨어뜨려서 세우는 방법이 있는지 알고싶은거다. 이 문제를 풀 수 있는 가장 쉬운 방법은 10명의 학생을 줄세우는 모든 경우의 수를 만들어, 각 경우에 사이 안 좋은 학생들이 붙어 있는지 확인하면 된다. 열 명의 학생들을 순서대로 세우는 방법은 대략 360만가지다.(10!) 컴퓨터에게 이 정도는 1초도 걸리지 않는다. 따라서 완전 탐색을 쓰면 어떻게 쉽게 푸는 방법이 없을까 고민할 필요 없이 무식하지만 간편하게 문제를 풀 수 있다. 

## 6.2 재귀 호출과 완전 탐색

### 재귀 호출

**범위가 작아지면 작아질수록 각 작업 조각들의 형태가 유사해지는 작업들이 있다.** 완전히 같은 코드를 반복해 실행하는 for 같은 반복문이 좋은 예다. 이런 작업을 구현할 때 유용하게 사용되는 개념이 `재귀 함수`다. 재귀함수란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수다.

```C
// 1부터 n까지 합을 계산하는 반복함수와 재귀함수

int sum(int n){
  int ret = 0;
  for(int i = 1; i <=n; i++){
    ret += i;
  }
  return ret;
}

int recursiveSum(int n){
  if(n == 1) return 1;
  return n + recursiveSum(n-1);
}
```

n개의 숫자의 합을 구하는 작업을 n개의 조각으로 쪼갠다. 더할 각 숫자가 하나의 조각이 되도록 하자. 재귀 호출을 위해서는 이 조각 중 하나를 떼어내 자신이 해결하고, 나머지 조각들은 자기 자신을 호출해 해결한다. 예를 들어, n만 따로 빼내자. 그러면 1부터 n-1까지의 조각들이 남는데, 이들을 모두 처리한 결과는 다름아닌 1부터 n-1까지의 합이다. 따라서 자기 자신을 호출해 n-1까지의 합을 구한 뒤, 여기에 n을 더하면 우리가 원하는 답이 된다.

위 예제의 재귀함수 첫 줄의 if문을 보자. 이 조건문이 없으면 이 함수는 동작하지 않는다. n=1이면 조각이 하나 뿐이니, 한 개를 빼고 나면 더 이상 진행할 작업이 없다. 모든 재귀 함수는 이와 같이 `더이상 쪼개지지 않는` 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 이 때 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 `기저 사례(base case)`라고 한다. 기저 사례 선택시 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 해야 한다. 


### 예제 : 중첩 반복문 대체하기

n개의 원소 중 네 개를 고르는(순서 O) 모든 경우 출력 해보자. n=7이면 (0,1,2,3), (0,1,2,4), (0,1,2,5), ... ,(3,4,5,6)의 모든 경우를 출력한다. 

```C
for(int i = 0; i < n; i++){
  for(int j = i+1; j < n; j++){
    for(int k = j+1; k < n; k++){
      for(int l = k+1; l < n; l++){
        cout<<i<<j<<k<<l;
      }
    }
  }
}
```

만약 다섯개를 고르면 5중 for문, 여섯개는 6중 for문이 된다. 위와 같은 중첩 for문은 골라야 할 원소의 수가 늘어날수록 코드가 길고 복잡해진다. 또한, 골라야 할 원소의 수가 입력에 따라 달라질 수 있는 경우에는 사용할 수 없다는 문제가 있다. 재귀 호출은 이런 경우에 단순 반복문보다 간결하고 유연한 코드를 작성할 수 있게 해준다.

**위 코드 조각이 하는 작업은 4개의 조각으로 나눌 수 있다. 각 조각에서 하나의 원소를 고르는 거다.** ~~n개의 원소 중 r개를 순서 없이 고르는 조합 문제다.~~ 이렇게 원소를 고른 뒤, 남은 원고들을 고르는 작업을 자기 자신을 호출해 떠넘기는 재귀 함수를 작성하자. 이 때 남은 원소들을 고르는 '작업'을 다음과 같은 입력들의 집합으로 정의할 수 있다. 

- 원소들의 총 개수
- 더 골라야 할 원소들의 개수
- 지금까지 고른 원소들의 번호

재귀함수로 코드를 작성해보자. for문 하나만을 별도의 함수로 떼낸 것과 유사하다.

```C
/**
  - n : 전체 원소의 수
  - picked: 지금까지 고른 원소들의 번호
  - toPick : 더 고를 원소의 수
  일 때, toPick개의 원소를 고르는 모든 방법 출력
**/
void pick(int n, vector<int>& picked, int toPick){
  // 기저 사례: 더 고를 원소 없을 때 고른 원소들을 출력
  if(toPick == 0) {printPicked(picked); return;}
  // 고를 수 있는 가장 작은 번호 계산
  int smallest = picked.empty() ? 0 : picked.back() + 1;

  for(int next = smallest; next < n; ++next){
    picked.push_back(next);
    pick(n, picked, toPick - 1);
    picked.pop_back();
  }
}
```

### 예제 : 보글게임 (난이도 : 하)

5x5크기의 알파벳 격자를 가지고 있다고 하자. 이 게임은 상하좌우/대각선으로 인접한 칸들의 글자들을 이어서 단어를 찾아내는 것이다. 각 글자들은 대각선으로 이어지거나, 한 글자가 두 번 이상 사용될 수 있다. 주어진 칸에서 시작하여 특정 단어를 찾을 수 있는지 확인할 수 있는 문제를 풀어보자. 일단 다음과 같은 함수를 작성하면 된다. `hasWord(y, x, word)`는 보글 게임판의 (y,x)에서 시작하는 단어 word의 존재 여부를 반환한다.

이 문제를 풀 때 가장 까다로운 점은 다음 글자가 될 수 있는 칸이 여러개 있을 때 이 중 어느 글자를 선택해야 할지 미리 알 수 없는 것이다. 예를 들어, YES라는 단어 찾을 때 첫 칸 Y 주변으 8칸에 모두 E가 들어있지만 이 중 YES로 연결되는 E는 오른쪽 위 칸 하나 뿐이다. 어느 E를 따라가야 답을 찾을 수 있을지 알 수 없다. 어떻게 해야할까?

간단한 방법은 완전 탐색을 이용해, 단어를 찾아낼 때까지 모든 인접한 칸을 하나씩 시도해 보는 것이다. 그중 한 칸에서라도 단어를 찾을 수 있으면 성공이고, 어느 칸을 선택하더라도 답이 없다면 실패다. 

### 문제의 분할

`hasWord()`가 하는 일을 가장 자연스럽게 조각내는 방법은 각 글자를 하나의 조각으로 만드는 것이다. 함수 호출시 단어의 시작위치를 정해 주기 때문이다. 시작 위치에 쓰여있는 글자가 단어의 첫 글자와 다르다면 곧장 false 반환 후 종료한다. 그러고 나면 원래 단어 word에서 첫 글자를 뗀 단어 word[1..]을 격자에서 찾아야 한다. word[1..]의 시작위치는 word[1..]의 시작 위치 (y,x)와 인접한 여덟칸 중 하나다. 따라서 8가지 경우 모두 시도하며 답을 찾으면 된다. 

### 기저사례의 선택

**더 이상의 탐색 없이 간단히** 답을 낼 수 있는 다음 경우들을 기저 사례로 선택한다. 

1. 위치(y,x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
2. (1번 경우에 해당되지 않을 경우) 원하는 단어가 한 글자인 경우 항상 성공

**간결한 코드 작성하는 유용한 팁은 **입력이 잘못되거나**, **범위에서 벗어난 경우**도 기저 사례로 택해서 맨 처음에 처리한다.** 그러면 함수 호출 시점에 이런 오류 잡아낼 필요가 없다. 이 습관은 반복적인 코드를 제거하는데 도움이 된다. 

### 구현

hasWord에서 시작 위치의 범위와 첫 글자 일치 여부를 확인하고 있다. **그래서 for문 안에서 별도로 확인 하지 않아도 된다. 다음 칸의 상대 좌표 목록을 함수 내에 직접 코딩해 넣은 것이 아닌, 별도의 변수로 분리해 낸 점도 참고하자.**

```C
const int dx[8] = [-1,-1,-1,1,1,1,0,0];
const int dy[8] = [-1,0,1,-1,0,1,-1,1];

bool hasWord(int y, int x, const string& word){
  if(!inRange(y,x)) return false;

  if(board[y][x] != word[0]) return false;

  if(word.size() == 1) return true;

  for(int direction = 0; direction < 8; ++direction){
    int nextY = y + dy[direction], nextX = x + dx[direction];

    if(hasWord(nextY, nextX, word.substr(1))){
      return true;
    }
  }
  return false;
}
```

### 시간 복잡도 분석

완전 탐색(brute-force) 알고리즘의 시간복잡도 계산 방법은 간단하다. 가능한 답 후보들을 모두 만들기 떄문에, 전부 세어보기만 하면 된다. 즉, 완전 탐색 알고리즘이 모든 경우에 시간 안에 동작함을 확인하기 위해 후보의 최대 수를 계산하면 된다. 

방금 작성한 알고리즘의 경우 답을 하나라도 찾으면 바로 종료하기 때문에 분석이 까다롭다. 최악의 경우는 답이 아예 존재하지 않는 경우인 때가 많다. 예를 들어 A로 가득찬 격자에서, 단어 AAAAAH를 찾는다고 하자. 격자에는 H가 아예 없기 때문에 단어를 찾을 가능성은 없지만, 완전 탐색은 그걸 모른다. 따라서 시작 위치에서 시작하는 모든 후보들을 빠짐없이 검사하면서, 단어의 끝에 도달해서야 답을 찾을 수 없다는 것을 알게 된다. 이 때 검사하게 되는 후보의 수는 마지막 글자에 도달하기 전에 주변의 모든 칸에 대해 재귀 호출을 한다. 단어의길이 N에 대해 N-1단계 진행된다. 따라서, 검사하는 후보의 수는 최대 `8^N-1` 이다. 


### 완전 탐색 레시피

어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 다음과 같다. 항상 적용되는 건 아니지만, 대략적인 지침은 된다.

1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 답의 수에 비례한다. 최대 크기의 입력 가정시 답의 개수를 계산하고이들을 모두 제한 시간안에 생성할 수 있는지 가늠한다. 시간 안에 계산 안되면 3부의 다른 장에서 소개하는 설계 패러다임 적용하자.

2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 된다. 

3. 그중 하나의 조각을 선택해 답의 일부를 만든다. 나머지 답은 재귀 호출을 통해 완성한다.

4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 `기저 사례`로 선택해 처리한다. 

### 이론적 배경: 재귀 호출과 부분 문제

재귀 호출시 중요한 개념 중 하나는 `문제`와 `부분문제`의 정의다. 동적 계획법이나 분할 정복과 같은 중요한 디자인 패러다임을 설명하는데 사용된다.

- 문제 : 주어진 자연수 수열을 정렬하라.
- 문제: {16,7,8,1,31}을 정렬하라.

같은 문제지만 전자는 입력이 없고, 후자는 입력이 있다. **재귀 호출 논의시 `문제`란 항상 수행해야 하는 작업과 그 작업을 적용할 자료의 조합을 말한다.** 보글 게임에서 **`문제`는 게임판에서의 현재 위치 (y,x) 그리고 단어 word가 주어질 때 해당 단어를 이 칸에서부터 시작해서 찾을 수 있는가? 로 정의**된다. 그러면 우리는 해당 단어를 이 위치에서 찾을 수 있는지알기 위해 최대 9가지 정보를 알아야 한다. 

1. 현재 위치 (y,x)에 단어의 첫글자가 있는가?
2. 윗 칸 (y-1, x)에서 시작해서, 단어의 나머지 글자를 찾을 수 있는가?
3. 왼쪽 윗 칸 (y-1, x-1)에서 시작해서 단어의 나머지 글자를 찾을 수 있는가?
4. ...
5. ...

이 중 2번 이후의 항목은 원래 문제에서 한 조각을 떼어냈을 뿐, 형식이 같은 또 다른 문제를 푼 결과다. 문제를 구성하는 조각들 중 하나를 뺐기 때문에, 이 문제들은 원래 `문제의 일부`라고 할 수 있다. 이런 문제들을 원래 문제의 `부분 문제`라고 한다.


## Summary

가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것이다. 이런 실수를 피하기 위해 `무식하게 풀 수 있을까?`를 스스로에게 물어보자.

brute-force는 가능한 경우의 수를 일일이 나열하며 답을 찾는 것.

When?
- 두 점 사이의 최단 경로 찾기 : 두 점 사이 경로 전부 만들어서 가장 짧은거 찾기
- 자원 분배할 수 있는 경우의 수 : 한가지씩 분배 방법 전부 만들어 보기
- 10명의 학생 줄 세우기. 단 조건은 사이 안 좋은 학생 떨어뜨려 놓기

How? 재귀호출

- 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지는 자기 자신을 호출해 실행하는 함수
- 이 때, 더이상 쪼개지지 않는 즉 작업 종료해야 할 상황을 가리켜 기저 사례라고 한다. 기저 사례를 선택해야 한다.

> n개의 원소 중 r개를 고르는 (조합) 모든 경우의 수 출력
- n중 for문으로 모두 구하기
- 재귀호출 이용
  - 숫자를 한 개 씩 선택(조각) 하는 작업을 n개의 조각으로 나누기
    - 원소들의 총 개수(a)
    - 더 골라야 할 원소들의 개수(b)
    - 지금까지 고른 원소들의 번호(c)
  - 기저 사례  
    - b가 0개면 종료

기저사례의 선택

- 더이상의 탐색 없이 간단히 답을 낼 수 있는 경우
- 입력이 잘못된 경우
- 범위에서 벗어난 경우 

> 완전탐색 레시피
1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 답의 수에 비례한다. 최대 크기의 입력 가정시 답의 개수를 계산하고이들을 모두 제한 시간안에 생성할 수 있는지 가늠한다. 시간 안에 계산 안되면 3부의 다른 장에서 소개하는 설계 패러다임 적용하자.
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 된다. (동일한 작업을 하는 조각) 
3. 그중 하나의 조각을 선택해 답의 일부를 만든다. 나머지 답은 재귀 호출을 통해 완성한다.
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 `기저 사례`로 선택해 처리한다. 

> 문제와 부분문제
재귀호출시 가장 중요한 개념 : 문제와 부분문제(조각)
- `문제`란 항상 수행해야 하는 작업과 그 작업을 적용할 자료의 조합, 보글 게임에서 **`문제`는 게임판에서의 현재 위치 (y,x) 그리고 단어 word가 주어질 때 해당 단어를 이 칸에서부터 시작해서 찾을 수 있는가? 로 정의**
- `부분 문제`란 문제를 풀기 위한 각 조각들




---

재구호출은 작업을 하고, 남은 작업을 자기 자신을 호출해 떠넘긴다.
