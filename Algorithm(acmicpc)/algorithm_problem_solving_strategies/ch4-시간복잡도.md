# 시간 복잡도

## 4.4 지수시간 알고리즘

## 다항 시간 알고리즘

N, N^2, N의 거듭제곱들의 선형 결합으로 이루어진 식들은 다항식이라고 부른다.

### 예제 : 알러지가 심한 친구들

최소 1개의 음식 알러지 있는 친구들이 있다고 하자. 각 친구가 먹을 수 있는 음식이 최소 하나씩 있으려면 최소 몇 가지 음식을 해야 할까?

#### 모든 답 후보를 평가하기

이 문제에서는 **여러 개의 답**이 있을 수 있다.  만들 수 있는 모든 음식을 한꺼번에 다 한다면 모두가 음식을 하나쯤은 먹을 수 있다. 하지만 최소 개수의 음식을 준비하고 싶다. **이렇게 여러 개의 답이 있고 그중 가장 좋은 답을 찾는 문제들을 풀 때 가장 간단한 방법은 모든 답을 고려해 보는 것이다.** 

만들 수 있는 음식의 모든 목록을 만드는 과정은 여러 개의 결정으로 나누면 자연스럽다. 우선, 첫 번째 요리를 할지 말지 결정하고, 그 다음엔 두 번쨰 요리를 만들지 말지 결정한다. 아래 그림처럼 맨 위의 텅빈 목록부터 시작하여, 각 음식을 만들지 말지 선택해 간다. 그림의 맨 끝까지 내려가 보면 마지막 목록을 보게된다. 모든 친구들이 식사할 수 있는 목록들만을 골라낸 뒤 가장 음식의 수가 적은 목록을 찾으면 된다. 

이 알고리즘을 구현하는 가장 쉬운 방법은 **재귀 호출**이다. 재귀 함수는 **그림에서의 한 상태를 입력 받아** 이 상태 밑에 달린 모든 후보들을 검사한다. 이 중 가장 최소 개수의 답을 반환하는 역할을 한다. 

```C
int M = 5;
const int INF = 99999999;

bool canEverybodyEat(const vector<int>& menu) {
    // 행은 사람 열을 음식 알러지 여부
    bool allergicList[3][5] = {false, true, true, false, false,
                    false, false, false, true, true,
                    true, false, true, true, false};

    // 행 : 사람
    for(int i = 0; i<3; i++) {
        bool isAllergicOkay = false;

        for (int j = 0; j<menu.size(); j++) {

            int foodIdx = menu[j];

            if(foodIdx == -1) continue;

            if(allergicList[i][foodIdx]) {
                isAllergicOkay = true;
                break;
            }
        }
        if(isAllergicOkay == false) {
            return false;
        }
    }
    return true;
}

int selectMenu(vector<int>& menu, int food) {
    if(food == M){
        if(canEverybodyEat(menu)) return menu.size();
        return INF;
    }

    int ret = selectMenu(menu, food + 1);

    menu.push_back(food);

    ret = min(ret, selectMenu(menu, food + 1));
    menu.pop_back();

    return ret;
}

int main() {
    vector<int> v;

    printf("%d\n", selectMenu(v, 0));

    return 0;
}
```

위 코드는 모든 답을 한 번씩 다 확인한다. 그래서 전체 걸리는 시간은 답의 수에 비례하게 된다. M가지의 음식마다 만든다, 안만든다 두 선택지가 있으니 만들 수 있는 답은 `2^M`가지다. 이 알고리즘이 오래 걸리는 이유는 무식하기 때문이다. 


### 예제: 소인수 분해의 수행 시간

**입력으로 주어지는 숫자의 개수가 아닌 그 크기에 따라 수행시간이 달라지는 알고리즘**들 또한 지수 수행시간을 가질 수 있다. 

예를 들어, 자연수 N이 주어질 때 N의 소인수 분해 결과를 반환하는 알고리즘이 있다고 하자. 이 알고리즈은 N이 1이 될 때까지 가능한 모든 숫자로 N을 나눈다. **따라서 N의 크기에 따라 반복문의 수행 횟수가 달라지게 된다.** 가능한 최악의 경우의 수는 주어진 수 N이 소수인 경우다. 

실행 횟수가 대략 N에 비례하기 때문에 이 함수는 최악의 경우 선형시간이 걸릴거라고 예상하기 쉽다. 그런데 N이 아무리 커져도 실제 입력은 1개일 뿐인데 수행시간이 달라지는 것은 직관과 맞지 않다.

```C
vector<int> factor(int n) {
    if(n==1) return vector<int>(1,1);
    vector<int> ret;
    for(int div = 2; n > 1; ++div) {
        while(n%div == 0) {
            n /= div;
            ret.push_back(div)
        }
    }
    return ret;
}
```

이런 불일치를 이해하기 위해 알고리즘의 수행시간과 입력이 메모리에서 차지하는 공간의 관계를 생각해보자. 입력의 값이 커지면 커질수록 숫자를 저장하는데 필요한 메모리 공간이 증가한다. 이때 입력이 차지하는 비트의 수에 따라 수행 시간이 증가한다고 생각하면 아까의 불일치를 직관적으로 설명할 수 있다.  입력의 값이 커질수록 숫자를 저장할 메모리의 공간도 증가할 거다.

## 4.5 시간 복잡도

시간복잡도란 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다. 여기서 기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산이다.

- 두 부호 있는 32비트 정수의 사칙연산
- 두 실수형 변수의 대소 비교
- 한 변수에 다른 변수 대입하기

가장 깊이 중첩된 반복문의 내부에 있는 기본적 연산들은 더 쪼갤 수 없기 때문에, 이것이 시간 복잡도의 대략적인 기준이 된다.

시간복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 뜻이다. 

### 입력의 종류에 따른 수행시간의 변화 

입력 종류에 따라 수행시간이 달라지기 때문에 

- 최선
- 최악
- 평균

적인 경우에 대한 수행시간을 따로 계산한다.

```C
int firstIndex(const vector<int>& array, int element) {
    for(int i = 0; i < array.size(); ++i) {
        if(array[i] == element) return i;
        return -1;
    }
}
```

- 최선 : 찾으려는 우너소 맨 앞에 있을 떄 => O(1)
- 최악 : 배열에 해당 원소 없을 떄 => O(N)
- 평균 : 존재할 수 있는 모든 입력의 등장 확률이 같고, 주어진 배열이 항상 원소를 찾는다고 하면 => O(2/N)

### 점근적 시간 표기 : O 표기

함수의 상한을 나타낸다. N이 엄청 커지게 되면 (N^2)과 (N^2 + 100*N + 1)사이에는 큰 차이가 없다. 이 때 적절한 상수 C를 선택하여 N^2에 곱해주면 항상 N^2이 더 크다고 볼 수 있다. 
