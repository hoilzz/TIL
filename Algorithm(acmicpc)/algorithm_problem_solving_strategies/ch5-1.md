# Chapter 5 알고리즘의 정당성 증명

## 5.1 알고리즘의 정당성 증명

문제가 복잡해지면 알고리즘이 문제를 제대로 해결하는지 파악하기 어렵기 때문에 수학적인 기법들을 동원해 증명을 하는 것이 좋다.

- 외우는 것보다 증명을 공부하는 것이 좋은 이유는 알고리즘을 유도하는 데 결정적인 통찰을 담고 있기 때문
- 여기서는 정당성 증명에서 흔히 나타나는 패턴들은 다른 알고리즘을 증명하는 데에 이용되므로 잘 이해하길 바람

## 5.2 수학적 귀납법과 반복문 불변식

수학적 귀납법은 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용되는 증명 기법이다.

귀납법 증명은 크게 세 단계로 나누어진다.

1. 단계 나누기
    - 증명하고 싶은 사실을 여러 단계로 나눔
    - 당연하게 생각되지만 중요한 과정
    - e.g., 100개의 도미노를 도미노 하나씩으로 나눈다.
2. 첫 단계 증명
    - 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.
    - e.g., 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
3. 귀납 증명
    - 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.
    - e.g., 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.

사다리 게임에서 맨 위 선택지와 맨 아래 선택지가 언제나 1:1 대응이 된다는 것을 귀납법으로 증명해보겠습니다.

1. 단계 나누기
    - 텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 됩니다.
2. 첫 단계 증명
    - 텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 됩니다.
3. 귀납 증명
    - 가로줄을 그어서 두 개의 세로줄을 연결했다고 합시다.
    - 이 때 두 세로줄의 결과는 서로 뒤바뀝니다.
    - 두 세로줄의 결과가 바뀌어도 1:1 대응은 변하지 않으므로 다음 단계에서도 1:1 속성이 유지됩니다.

![5_1.png](https://github.com/showerbugs/book-study/raw/master/algorithm_problem_solve/5_1.jpeg)

## 반복문 불변식

귀납법을 이용해 알고리즘의 정당성을 증명할 때는 `반복문 불변식`이라는 개념이 유용하게 쓰입니다.

- 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건입니다.
- 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 하는 것이죠

불변식을 이용하면 반복문의 정당성을 증명할 수 있습니다.

1. 반복문 집입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다.
    - 반복문 내용이 시작할 때 불변식이 성립했다면 끝날 때도 항상 성립한다.
3. 반복문 종료시에 불변식이 성립하면 항상 불변식이 성립되됨을 보일 수 있다.

예를 들어 while 문에서 실제 불변식이 성립함을 보여야 하는 위치는 다음과 같습니다.

```cpp
// (*) 불변식은 여기에서 성립해야 한다.
while (condition) {
    // 반복문 내용의 시작
    ....
    // 반복문 내용의 끝
    // (**) 불변식은 여기에서도 성립해야 한다.
}
```

## 이진 탐색과 반복문 불변식

```cpp
// 필수 조건: A는 오름차순으로 정렬되어 있다.
// 결과: A[i-1] < x <= A[i]인 i를 반환한다.
// 이때 A[-1] == 음의 무한대, A[n] == 양의 무한대라고 가정한다.
int binsearch(const vectorint>& A, int x) {
    int n = A.size();
    int lo = -1 ,hi = n;
    // 반복문 불변식 1: lo < hi
    // 반복문 불변식 2: A[lo] < x <= A[hi]
    // (*) 불변식은 여기서 성립해야 한다.
    while(lo + 1 < hi) {
        int mid = (lo + hi) / 2;
        if(A[mid] < x)
            lo = mid;
        else
            hi = mid;
        // (**) 불변식은 여기서도 성립해야 한다
    }
    return hi;
}
```

여기서는 이렇게 증명합니다.

`반복문 불변식`이 성립 > `알고리즘` 증명

### 반복문 불변식이 성립하는지 확인

그럼 반복문 불변식이 성립하는지 확인해보겠습니다.

1. 초기 조건
    - while문이 시작할 때 lo와 hi는 초기값 -1과 n으로 초기화된 상태
    - `n=0` 일때
        - 불변식 1은 while문을 건너뛰기 때문에 항상 성립
        - 불변식 2는 A[-1] = 음의 무한대, A[n] = 양의 무한대로 가정하기 때문에 성립
2. 유지조건
    - 불변식 1 `(lo < hi)`
        - while문 내로 들어왔다는 말은 hi와 lo의 차이가 2 이상이라는 의미
        - mid는 항상 두 값의 사이에 위치
        - mid를 lo에 대입하건, hi에 대입하건 불변식 1은 항상 유지
    - 불변식 2 `(A[lo] < x <= A[hi])`
        - A[mid] < x 인 경우
            - 반복문을 시작할 때 `x <= A[hi]` 는 이미 알고 있었음
            - `A[mid] < x <= A[hi]` 이므로 lo에 mid를 대입해도 불변식 성립
        - x <= A[mid] 인 경우
            - 반복문을 시작할 때 `A[lo] < x` 는 이미 알고 있음
            - `A[lo] < x <= A[mid]` 이므로 hi에 mid를 대입해도 불변식 성립

그래서 반복문 불변식 1, 2는 항상 성립한다고 볼 수 있음

### 반복문 불변식이 성립한다고 가정할 경우

만약 반복문 불변식 1, 2가 모두 끝까지 성립했다고 가정하면 우리는 알고리즘을 증명할 수 있을 겁니다.

1. lo + 1 = hi
    - while문이 종료했으니 lo + 1 >= hi일 것입니다, 불변식에 의해 lo < hi 이므로 lo < hi <= lo + 1
    - lo + 1 == hi 일수밖에 없습니다.
2. A[lo] < x <= A[hi]
    - 애초에 불변식이 성립한다고 가정했으므로 이 또한 성립합니다.

결국 우리가 원하는 결과값 i는 A[i - 1] < x <= A[i] 인 i이므로 우리가 원하는 결과는 hi라는 사실을 알 수 있습니다.


## 삽입 정렬과 반복문 불변식

```cpp
void insertionSort(vector<int>& A){
    for(int i = 0; i < A.size(); i++) {
        // 불변식 a: A[0..i-1]은 이미 정렬되어 있다.
        // A[0..i-1]에 A[i]를 끼워넣는다.
        int j = i;
        while(j > 0; && A[j-1] > A[j]) {
            // 불변식 b: A[j+1..i]의 모든 원소는 A[j]보다 크다.
            // 불변식 c: A[0..i] 구간은 A[j]를 제외하면 정렬되어 있다.
            swap(A[j-1], A[j]);
            --j;
        }
    }
}
```

불변식 a는 시작할 때 항상 구간 A[0..i-1]이 정렬되어 있어야 한다고 선언합니다.

- 불변식에 따르면 i가 n이 되어 for문이 종료했을 때, A 전체가 정렬된 상태가 됩니다.
- 그렇기 때문에 불변식 a가 항상 참임을 보여주면 알고리즘의 정당성이 증명됩니다.

1. 초기조건
    - 반복문이 시작할 때 `i=0` 이면 해당 구간은 비어 있으니 항상 정렬되어 있다고 가정할 수 있습니다.
2. 불변식 유지
    - for문의 내용이 종료할 때 이 불변식이 깨지지 않고 유지됨을 보이기 위해서는 while문의 정당성을 증명해야 합니다.

while문의 정당성은 `불변식 b,c`를 이용해 증명합니다.

- `불변식 b와 c`가 성립하면 `불변식 a`도 성립합니다.
- **불변식 b**: A[j+1..i]의 모든 원소는 A[j]보다 크다.
- **불변식 c**: A[0..i] 구간은 A[j]를 제외하면 정렬되어 있다.

![5_2.png](https://github.com/showerbugs/book-study/raw/master/algorithm_problem_solve/5_2.jpeg)

1. `j=0`이라면 `불변식 b`에 의해
    - A[j]가 A[0..i] 구간 중에서 가장 작은 수가 되어 A[0..i] 구간 전체가 정렬되어 있음을 알 수 있습니다.
2. `j>0`이고 A[j-1] <= A[j] 이면 `불변식 b`와 합쳐
    - `A[j-1] <= A[j] < A[j+1]` 가 됩니다.
    - 불변식 c와 합쳐보면 A[0..i] 구간 전체가 정렬되어 있음을 알 수 있습니다.

마지막으로 불변식 b, c가 항상 성립함을 증명해보겠습니다.

### 불변식 b

1. 초기조건
    - while문 진입시에 A[j+1..i] 구간은 빈 구간이므로 b는 참
2. 유지조건
    - while문 내용이 실행되었다는 말은 `A[j-1] > A[j]` 라는 의미이니, 이 둘을 교체하고 j를 줄이면 b는 여전히 참

### 불변식 c

1. 초기조건
    - 불변식 a에 의해 구간 A[0..i-1]은 정렬되어 있으니 while문 진입시에 항상 참
2. 유지조건
    - A[j]와 이전 원소를 교체한다고 해도 회색 원소드간의 상대적 순서는 변하지 않기 때문에 항상 유지됨

이 증명은 while문이 항상 A[0..i]를 정렬된 상태로 남겨둔다는 것을 보여주기 때문에 알고리즘의 정당성이 증명된다.


## 단정문을 이용해 반복문 불변식 강제하기

주석 말고 assert문을 사용해 강제 종료되게 하면 문제를 빠르게 파악할 수 있다.

> 하지만 이 또한 적당히 하는게 좋겠지

## 5.3 귀류법

## 철도 문제 Question

지금 막 출발한 완행 열차의 차장이 철도청 웹 사이트의 오류 때문에 규정 인원보다 많은 승객이 표를 예매했다는 것을 깨달았다고 합시다.

최소한의 승객을 내쫓을 수 있는 방법을 설명하시오.

## 철도 문제 Answer

답은 가장 멀리 가는 순서대로 내쫓는 것입니다.

가장 멀리 가는 사람을 내쫓는 대신 다른 사람을 내쫓았을 때 더 좋은 결과가 나오는 상황이 없기 때문입니다.

- 멀리 가는 사람은 쭈욱 그 자리에 앉아 있기 때문이다

이처럼 우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못되었음을 찾아내는 증명 기법을 귀류법이라 한다.

> 이 책에서는 대개 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용된다.

## 책장 쌓기 Question

상자 형태로 된 책장을 여러 개 쌓아 올리려고 합니다.

- 상자들은 자기 자신의 무게(Wi)와 버틸수 있는 무게(Mi)를 가지고 있습니다.

이때 가장 높이 쌓는다면 몇개나 쌓을 수 있을까요?


## 책장 쌓기 Anser

책장을 쌓기 가장 좋은 방법은 `Mi + Wi 가 큰 것`부터 아래에 놓는 것입니다.

이를 귀류법으로 증명해 보겠습니다. 귀류법을 쓰기 위해 우리가 증명하려는 사실의 반대를 가정해보겠습니다.

어떤 입력의 최적해를 구했는데 `Mi + Wi`가 더 큰 책장 A가 더 작은 책장 B위에 올라간 형태라고 가정해 봅시다.

![5_3.png](https://github.com/showerbugs/book-study/raw/master/algorithm_problem_solve/5_3.jpeg)

## 귀류법을 이용한 증명들

이 책에서는 알고리즘의 결과가 최선임을 보이기 위해 귀류법을 사용합니다.

- 각 단계에서 최선의 선택인지 증명하고 그걸 바탕으로 결과가 최선임을 증명
- 최단 경로, 높은 탑 쌓기

## 5.4 다른 기술들

## 비둘기집의 원리

대한민국 국민들 중 머리털 개수가 정확히 같은 두사람이 존재할까요?

- 사람 머리카락 수는 많아봐야 100만개, 당연히 있겠죠

비둘기집의 원리는 10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어간 비둘기 집이 반드시 하나는 있기 마련이다.

## 동전 뒤집기

100개의 동전이 바닥에 깔려 있는데 이 중 F개는 앞면, 100-F개는 뒷면이 위로 놓여 있습니다. 우리는 모든 면을 앞면으로 바구고 싶은데, 한번 뒤집을 때 반드시 X개의 동전을 한꺼번에 뒤집어야 한다.

이때 뒤집는 횟수를 최소화했을 때 답의 상항이 몇번이나 될까요?

정답은 100입니다.

동전을 한번 뒤집을 때마다 앞면의 개수를 기록한다고 했을 대

- 어떤 답에서 동전을 101번 뒤집었다면 F까지 합쳐 102개의 숫자를 적게 됩니다.
- 앞면의 개수는 0~100까지 101가지의 값만을 가질 수 있으므로 비둘기집의 원리에 따라 중복이 발생할 수밖에 없어 최선의 답이 아님
- 그러므로 100임

## 순환 소수 찾기

분수 a/b가 주어질 때 실수 연산을 쓰지 않고 이 분수를 소수 형태로 출력하려 합니다.

예를 들어 `3/8 = 0.375` `4712/400 = 11.78` 같이 말이죠

```cpp
void printDecimal(int a, int b){
    int iter = 0;
    while(a > 0) {
        // 첫 번째와 두번째 사이에 소수점 찍음
        if(iter++ == 1) cout << '.';
        cout << a / b;
        a = (a % b) * 10;
    }
}
```

근데 무한소수가 있을 경우가 있을 텐데 그건 어떻게 판별할까요

- 1/11 == 0.0909090909...
- 영영 안끝나겠죠

비둘기 집의 원리를 쓰면 쉽게 해결할 수 있습니다.

`a = (a % b) * 10` 에서 `a % b`의 결과는 언제나 [0,b-1]의 범위를 갖습니다.

즉 while문이 b+1번 반복될 때까지 함수가 종료되지 않았을 경우, 비둘기집의 원리에 따라 순환소수라고 판단할 수 있습니다.

## 구성적 증명

구성적 증명은 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해서 사용됩니다.

- 답의 실제 예를 들거나 답을 만드는 방법을 실제로 제시하는 증명

예를 들어 하늘을 나는 교통 수단을 만들 수 있다는 주장을 증명하려 한다고 합시다.

비구성적 증명에서는

- 양력의 법칙에서부터 시작해 지구의 공기 밀도, 재료들의 강도와 탄성들을 하나하나 열거해가며 하늘을 날 수 있음을 보이려 할 겁니다력

하지만 구성적 증명이 하는 일은 비행기를 만들어서 보여주거나 만드는 법이 적힌 설명서를 건네주는 것입니다.

> 답이 존재하는가에 대한 대답으로 이렇게 만들면 된다라고 하는 것이 구성적 증명이기 때문에, 내용이 알고리즘인 경우가 많습니다.
