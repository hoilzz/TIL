# 차이를 최대로

```
|A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|
```

`N(2<N<9)` 개의 정수로 이루어진 배열(-100보다 크거나 100보다 작은 수)이 있다.
배열에 들어있는 정수의 순서를 적절히 바꿔 위 식의 최대값을 구하는 프로그램 만들자.

## Solution

식의 최대 개수는 `8!` 약 40,000 이다. `다 해보기` 전략을 사용한다.

모든 식을 조사해보기 위해 `next_permutation()`을 이용한다.

`next_permutation`는

	- 다음 순열이 있다면 그 배열을 다음 순열로 바꿔주고 true 반환
		- 비교함수가 주어지지 않는다면 다음순열은 `오름차순-내림차순`이다.
	- 마지막인 `내림차순`으로 재정렬 후, 다시 `next_permutation` 수행하면 false 반환 후, 초기값으로 재정렬한다.

위 함수를 이용하여 처음부터 끝까지 조사하기 위해, `sort`로 `오름차순` 정렬 한다.

## 회고

내가 생각한건 완벽한식.. 
`가장 큰값 - 가장 작은 값` 이런 형태를 띠는 식이면 완벽한 값이 나올 거라 생각했다. 하지만 하나의 값이 음수, 양수 둘 다 될 수 있으므로 내가 만든 식은 답을 내기엔 불완전했다.

- 내림차순으로 정렬한다
- `[0]`번째 값과 `[N-1]` 차이를 계산한다
- `[1]`번째 값과 `[N-2]` 차이를 계산한다
- 이런식으로 N이 정중앙 index까지 오면 완벽한 식이라고 생각했다.

결론은 한가지 숫자가 음수,양수 될 수 있다는 변수때문에 위 식은 틀렸다.

`전부 다 해보기`를 생각 못했다.

일단 N값이 작고 나올 수 있는 식의 최대 개수를 계산 해봤으면, `다 해보기`를 떠올릴 수 있었다. N값이 작으면 일단 의심하자. 그렇지 않더래도 주어진 조건으로 `총 경우의 수`를 생각해보자.
