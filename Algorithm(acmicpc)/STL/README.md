# STL

C++의 STL에서 지원하는 컨테이너

	- std:vector
	- std:list
	- std:map

에 대해 알아보자.

---

## 자료구조

먼저 자료구조에 대해 간단히 알아보자.

자료구조는 자료를 효율적으로 다루기 위한 개념이다.

자료구조는 대표적으로 `검색`, `입력`, `출력`, `삭제`, `삽입` 코드를 스스로 작성 해봐야한다.

---

### 1. 큐

지원하는 동작이 넣고 빼기 뿐이다.

서버 입장 대기, 채팅에 주료 사용된다.


### 2. 스택

프링글스 통의 감자칩 같은 거다.

함수의 호출은 스택으로 이뤄진다.

디버깅시 `호출 스택`이 바로 이거다.

### 3. 배열

메모리에 있는 주소에 직접 접근 가능하다.

```C
int ArrData[100000] = {0};
printf("%d", ArrData[999]);
```

완전 간단하고, 완전 빠르다.

단점은 한번 잡은 메모리 최대 인덱스는 불변하다.

이 단점은 `std::vector`로 극복할 수 있다.

### 4. 리스트

LinkedList로 이해하자. (예 : 지하철)

*LinkedList*
```C
struct LinkedList{
	int data;
	LinkedList *nextNode;
}
```

리스트는 배열과 달리 길이가 가변적.

자료의 길이를 늘리고 싶으면 새로 생성한 노드를 기존의 리스트의 노드 끝에 붙이면 된다.

단점은 검색에 약하다.

1000개의 노드에서 900번째 노드의 값을 찾으려면?

우리가 아는 것은 노드의 첫번째 주소 밖에 없다. 첫번째 노드부터 O(N)번 검색해야 한다.


### 트리

내 컴퓨터의 폴더를 떠올리면 좋다.

C 드라이브를 열면 다른 폴더들이 있는 구조다.

트리도 역시 여러 구조가 있다.

`완전 이진트리`, `이진 트리`, `AVL`, `RED BLACK` 등이 있다.

종류는 다 다르지만 결국 `최대한 빨리 찾는 것`을 목적으로 각자 다른 검색 방법을 사용한다.

트리에 자식이 추가되면 이를 어떻게 `잘 섞는가`에 따라 종류가 다르다.

장점
	- 트리는 `검색`에 있어서 자료구조들 중에서 평균적으로 빠르다.

트리의 구조는

root에 자식이 있고 그 자식이 또 자식이 있는 구조다.

리스트가 다음 노드 주소만 가질 수 있다면, 트리는 여러개를 가진다.

대부분의 경우 이진트리 구조로 간다.

```C
struct Tree
{
	int Data;
	Tree *LeftChild;
	Tree *RightChild;
}
```

트리는 노드로 구성되기 때문에 배열과 달리 그 메모리 길이가 `가변`이다.

찾는 속도는 배열 보다는 느리지만, 평균적으로 빠르다.


## STL 컨테이너

std:vector
