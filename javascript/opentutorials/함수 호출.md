# apply (aka 함수호출)

자바스크립트에서 함수라고 하는 것은 객체다!
**함수는 객체다**

**객체는 속성을 가진다**
**속성에 함수가 들어있다면 그것을 메서드라고 부른다**

## apply
함수.apply()

Ex
  function sum (arg1, arg2) {
    return arg1+arg2;
  }

  sum.apply // function apply() { [native code]}
            // apply는 내장 함수라 노출 안됨

아래 2줄은 결과가 같다.

  sum.apply(null, [1,2])
  sum(1,2)

왜 사용하는지 알기 위해 null에 다른걸 넣어보자

## WHY?


#### Ex

  o1 = {val1:1, val2:2, val3:3}
  o2 = {v1:10, v2:50, v3:100, v4:25}
  function sum(){
    var _ sum = 0;
    for (name in this) {
      _ sum += this[name];
    }
    return _ sum;
  }
  alert(sum.apply(o1));
  alert(sum.apply(o2));

sum은 for in 문을 이용하여 객체 자신(this)의 값을 열거한 후에 각 속성의 값을 지역변수 _ sum에 저장 후 리턴하고 있다.

객체 function의 메소드 apply의 첫번째 인자는 함수가 실행될 맥락이다. sum.apply(o1)은 함수 sum을 객체 o1의 메소드로 만들고 sum을 호출한 후 sum을 삭제한다. 아래와 비슷하다

  o1 = {val1:1, val2:2, val3:3, sum:sum}
  o1 = {val1:10, val2:50, val3:100, v4:25 sum:sum}

  alert(o1.sum());
  alert(o2.sum());

  // 근데 코드가 그대로 출력된다. 왜냐면 o1의 마지막 속성이 for in 문에 들어간다. this[name]의 typeof 가 function이면 썸에 안더하면 된다.


## Summary
- 함수 sum에서 this의 값이 전역객체가 아니라 o1이 된다는 의미
- 일반적인 객체지향 언어에서 하나의 **객체에 소속된 함수는 그 객체의 소유물** 이 됨
- 하지만 **JS 에서는 함수는 독립적인 객체** 로 존재, apply 메서드를 통해 다른 객체의 소유물인 것처러 ㅁ실행 가능
- apply의 첫째 인자로 null 전달시 apply가 실행된 함수 인스턴스는 전역객체(브라
  우저에서는 window)를 맥락으로 실행
