# 변수와 스코프, 메모리

- 변수의 원시 값과 참조값
- 실행 컨텍스트의 이해
- 가비지 컬렉션의 이해

## 4.1 원시 값과 참조값

변수는 `원시 값`과 `참조 값` 두 가지 타입의 데이터 저장 가능.

변수에 값을 할당시 js 엔진은 해당 값이 원시 / 참조 인지 판단한다.
- 원시값 : 단순 데이터
	- `값으로 접근(call by value)`, 변수에 저장된 실제 값을 조작

- 참조 값 : 여러 값으로 구성되는 객체
  - `참조로 접근(call by ref)`, 해당 객체에 대한 `참조`를 조작
  - 메모리에 저장된 객체인데, js는 메모리 위치에 직접 접근하는 것을 허용하지 않는다.
  - 객체 조작시 사실 객체 자체가 아닌 해당 객체에 대한 `참조`를 조작하는 것이다.


## 4.1.1 동적 프로퍼티

- **참조값을 다룰 때는** 언제든 프로퍼티와 메서드를 추가 수정 삭제할 수 있다.

```javascript
  var person = new Object();
  person.name = "Nicholas"
  alert(person.name); // **Nicholas**
```

```javascript
  var name = "Nicholas";
  name.age = 27;
  alert(name.age);  // **undefined**
```

문자열 name에 age란 프로퍼티를 정의했다.

하지만 다음 줄에서 프로퍼티는 없어졌다.

**동적으로 프로퍼티를 추가할 수 있는 값은 참조 값 뿐이다**

원시 값에는 프로퍼티가 없지만 추가해도 에러는 생기지 않는다.



## 4.1.3 매개 변수 전달

변수는 `값, 참조`로 접근 가능.

**하지만 매개변수는 오직 `값`으로만 전달**


### 매개변수를
- `값` 형태로 넘기면 해당 값은 지역변수에 복사
- `참조` 형태로 넘기면 메모리 상의 위치가 지역변수에 저장.
	- **지역 변수 변경시 함수 바깥에도 해당 변경 내용 반영**. 주의하자.


## 4.1.4 타입 판별
`typeof`, `instanceof`

`typeof` 연산자는 변수가 원시 타입인지 파악하기에 최상이다.

근데 참조 값에 대해서는 쓸모가 없다.

일반적으로, **값의 객체 유무보다는 어떤 타입의 객체인지 알고** 싶어한다.

ECMAScript의 `instanceof` 연산자가 이럴 때 도움된다.



### instanceof

변수가 주어진 참조 타입의 인스턴스일 때 true 반환

```javascript
  person instanceof Object // person변수가 Object의 인스턴스인가?
  colors instanceof Array
```

- 모든 참조 값은 Object의 인스턴스로 정의되어있으므로 항상 true 반환
- 반면 원시 값은 Object의 인스턴스가 아니므로 false 반환

## 4.2 실행 컨텍스트와 스코프

**execution context** 는 컨텍스트라고 부르며 중요한 개념이다.

- 변수, 함수의 실행 컨텍스트는 다음을 규정한다.
	- **다른 데이터에 접근할 수 있는지**
	- **어떻게 행동하는지**

- 각 **실행 컨텍스트에는 변수 객체(variable object)가 연결됨**.
  - **해당 컨텍스트에서 정의된 모든 `변수`와 `함수`는 이 객체에 존재**

가장 바깥쪽에 존재하는 실행 컨텍스트는 `전역 컨텍스트`다.
- 웹 브라우저에서는 이 컨텍스트를 `window`
  - 전역 변수와 함수는 모두 `window` 객체의 프로퍼티 및 메서드로 생성

**함수를 `호출`하면 독자적인 실행 컨텍스트 생성**
- **코드 실행이 함수로 들어갈 때마다 함수의 컨텍스트가 컨텍스트 스택에 쌓인다**
- **함수 실행이 끝나면 해당 컨텍스트를 스택에서 꺼내고 컨트롤을 이전 컨텍스트에 반환**

**컨텍스트에서 코드를 실행하면** 변수 객체에 `스코프 체인`이 생성됨
  - 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것
  - 컨텍스트가 함수라면 활성화 객체를 변수 객체로 사용한다.

> 함수 매개변수도 변수로 간주된다. 실행 컨텍스트에 있는 다른 변수와 같은 규칙을 따른다.

*스코프 체인 예제*

```javascript
var color = "red";

function changeColor(testargu){
  var anotherColor = "blue";

  function swapColor(){
    console.log("****before****");
    console.log("color : " + color);
    console.log("anotherColor : " + anotherColor);

    var temp = color;
    color = anotherColor;
    anotherColor = temp;

    console.log("\n\n****after****");
    console.log("color : " + color);
    console.log("anotherColor : " + anotherColor);
    console.log("testargu : " + testargu);

    // color, anotherColor, tempColor 모두 접근 가능
  }
  swapColor(); // color, anotherColor 접근 가능, tempColor 접근 불가능
}

changeColor("hoilzzang"); // color만 접근 가능

// 출력값
// "****before****"
// "color : red"
// "anotherColor : blue"

// ****after****"
// "color : blue"
// "anotherColor : red"
// "testargu : hoilzzang"
```

- 코드 실행시 변수객체에 스코프 체인 생성.

#### Summary
- 실행 컨텍스트는 다른 데이터에 접근 가능 여부를 판단한다.
  - 실행 컨텍스트는 전역 컨텍스트와 함수 컨텍스트가 있다.

- 스코프 체인은 컨텍스트에서 코드 실행시 변수 객체에 scope chain 만든다.
- 지역변수와 전역변수의 개념..

```javascript
  var color = "blue"
  function changeColor() {
    if (color === "blue") {
      color = "red";
    } else {
      color = "blue"
    }
  }
```

`changeColor()`의 스코프 체인에는 **2개의 객체**가 있다.
- 1 함수 자체의 변수 객체, 2 전역 컨텍스트의 변수 객체 (color)


## 4.2.1 스코프 체인 확장

임시 객체가 생성되는 2가지 경우
1 try-catch문의 catch 블록
2 with 문

두 문장은 모두 스코프 체인 앞에 변수 객체를 추가
- with 문에서는 해당 객체가 스코프 체인에 추가
- catch문은 에러 객체를 선언하는 변수 객체가 생성

```javascript
  function buildUrl() {
    var qs = "?debug=true";

    with(location) {
      var url = href + qs;
    }
    return url;
  }
```

- `with` 문이 location 객체에 적용되므로 location 객체가 스코프 체인에 추가됨
- href를 참조하는 문장은 location.href 변수 참조하는 것
- `with` 문 내부에서 선언한 변수 url은 함수의 컨텍스트로 편입, 따라서 함수 값으로 반환 가능



## 4.2.2 자바스크립트에는 블록 레벨 스코프가 없다

C에서는 중괄호로 감싼 코드 블록마다 스코프가 생성.

조건에 따라 변수를 정의할 수 있다. 이를 `블록 레벨 스코프`라고 한다.

```javascript
  if (true) {
    var color = "blue"
  }
  alert(color) // 'blue'
```

변수 color는 if 문 안에서 정의 되었다.

C에서는 color는 if문 실행 후 파괴된다.

하지만 **js에서는 변수 선언시 해당 변수를 현재 execution context(위 코드에서는 전역 컨텍스트)에 추가**


### 식별자 검색

식별자 검색 순서

  1. 로컬 컨텍스트
  2. 스코프 체인 따라 검색 계속 (스코프 체인 내부의 객체에 프로토타입 체인이 있으므로 체인 따라 검색할 수도 있다.)
  3. 전역 컨텍스트 변수 객체에서 찾기
  4. 없으면 정의 안된걸로 판단

```javascript
  var color = "blue";
  function getColor() {
    return color;
  }
  alert(getColor()); //blue

  // window - color
  //        - getColor return color
```

> 변수 검색에도 비용이 들어간다. 지역 변수는 스코프 체인을 따라 올라가며 검색할 필요가 없으므로 전역 변수보다 빨리 검색된다.
js 엔진에서 식별자 검색을 최적화하고 있으므로 미래에는 이런 차이가 무실할 정도로 좁혀질 수도 있다.


## 4.2 가비지 콜렉션

자바스크립트는 필요한 메모리를 자동으로 할당하고 더 이상 사용하지 않는 메모리는 자동으로 회수하므로

개발자가 직접 메모리 관리하지 않아도 된다.

개념은 단순하다.

더 이상 사용하지 않을 변수를 찾아내서 해당 변수가 차지하던 메모리를 회수한다.

이 프로세스는 주기적으로 실행되는데 코드 실행 중에 특정 시점에서 메모리를 회수하도록 지정할 수 있다.

예를 들어, 함수의 지역 변수 선언시 해당 시점에서 스택에 변수의 값을 저장할 메모리가 할당된다.

변수는 함수 안에서만 존재하므로 함수 종료시 변수는 필요하지 않다.

이런 상황에서는 분명 해당변수가 더 이상 필요 없지만 분명하지 않은 경우도 있다.

가비지 콜렉터는 어떤 변수가 더 이상 사용되지 않는지, 사용될 가능성이 있는 변수는 무엇인지 추적해야 메모리 회수 대상을 정할 수 있다.

더 이상 사용하지 않는 변수를 식별하는 기준은 브라우저마다 다르지만 보통 두 가지 방법을 사용한다.



### 4.3.1 표시하고 지우기

js에서 가장 널리 쓰이는 가비지 컬렉션 방법이다.

변수가 특정 컨텍스트 안에서 사용할 것으로 정의되면(예를 들어 함수 안에서 변수 정의시)

그 변수는 그 컨텍스트 안에 있는 것으로 표시된다.

컨텍스트 안에 존재하는 변수의 메모리는 해제해서는 안되는데, 해당 컨텍스트가 실행 중인 한 사용될 가능성이 있기 때문이다.

변수에 표시하는 방법은 다양하다.

  - 변수가 컨텍스트 안에 있을 때 특정 비트를 on상태로 표시
  - `컨텍스트 내부`, `컨텍스트 외부`를 나타내는 변수 목록을 따로 두어 변수의 움직임을 추적

이를 어떻게 구현했냐는 중요하지 않은 탁상공론이다.

> 가비지 컬렉터 작동하면 메모리에 저장된 변수 전체에 표시를 남긴다.
그 다음 컨텍스트에 있는 변수와, 컨텍스트에 있는 변수가 참조하는 변수에서 표시를 지운다.
이 과정을 거친 다음에도 표시가 남아 있는 변수는 컨텍스트에 있는 변수와 무관하므로 삭제해도 안전하다.
가비지 컬렉터는 `메모리 청소`를 실행해 표시가 남아 있는 값을 모두 파괴하고 메모리를 회수한다.


### 4.3.2 참조 카운팅



### 4.3.3 성능

가비지 컬렉터는 주기적으로 실행되며 메모리 내에 할당된 변수가 많다면 상당한 비용이 드는 작업이다.

그래서 가비지 컬렉션을 실행하는 타이밍이 중요하다.


### 4.3.4 메모리 관리

js 환경에서 메모리 관리와 가비지 콜렉션은 다른 환경과 매우 다르다.

웹 브라우저에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다.

그 이유는 웹 페이지에서 실행하는 js가 시스템 메모리를 전부 사용해서 OS를 다운시키는 일을 방지하기 위함이다.

메모리 제한은 변수 할당 뿐만 아니라 호출 스택, 스레드에서 실행할 수 있는 문장 수에도 영향을 미친다.

<br>

가능한 최소한의 메모리만 사용하여 성능을 올리자.

메모리 사용을 최적화하는 가장 좋은 방법은 `코드 실행에 필요한 데이터만 유지하는 것`이다.

필요 없어진 데이터에는 `null`을 할당하여 참조를 제거하자.

수동으로 참조 제거해야 할 대상은

  - 주로 `전역 변수` 및 `전역객체 프로퍼티`다.

  - **지역 변수는 컨텍스트를 빠져나가는 순간 자동으로 참조가 제거된다.**

```javascript

functino createPerson(name){
  var localPerson = new Object();
  localPerson.name = name;
  return localPerson;
}

var globalPerson = createPerson("Nicholas");

```

이 코드에서 변수 globalPerson의 값은 createPerons() 반환 값이다.

createPerson() 함수는
  - localPerson 객체를 만들고
  - name property를 추가한다.
  - createPerson()함수는 변수 localPerson을 반환하며 이 값은 globalPerson에 할당된다.

createPerson()함수가 실행을 마치는 순간 localPerson은 컨텍스트를 벗어난다.
(함수 종료시 실행 컨텍스트 stack에서 자동으로 제거된다.)

그래서 명시적으로 참조 제거할 필요 없다.

반면, globalPerson은 `전역변수`다.

코드 마지막 줄과 같이 직접 참조를 제거해야 한다.

**변수에서 참조를 제거한다 해서 할당된 메모리가 자동으로 반환되는 것은 아니다.**

**참조 제거의 요점은 값의 컨텍스트를 없애서 다음에 가비지 콜렉션을 실행 할 떄 해당 메모리를 회수해가도록 하는 것이다.**



## 4.4 요약

자바스크립트 변수는 `원시 값`, `참조 값` 2가지 형태로 저장 가능
`원시 값` : 불리언, 숫자, 문자열, undefined, null

- 원시값은 고정된 크기를 가지며 스택 메모리에 저장
- 원시 값을 한 변수에서 다른 변수로 복사하면 값자체가 복사됨
- 참조 값은 객체이며 힙 메모리에 저장
- 변수에 참조 값을 저장하면 참조만 저장할 뿐 객체 자체를 저장하는 것 아님
- 참조 값을 한 변수에서 다른 변수로 복사하면 참조만을 복사하므로 같은 객체를 참조
- typeof 연산자는 원시 타입 판별, instanceof 연산자는 값의 참조 타입 판별

원시 값과 참조 값을 가리지 않고 모든 변수는 스코프라고 부르기도 하는 `execution context`에 존재
실행 컨텍스트는
- **변수가 존재하는 기간을 결정**
- **어느코드가 해당 변수에 접근할 수 있는지도 결정**
- 실행 컨텍스트에는 **전역 컨텍스트와 함수 컨텍스트** 가 있다
- 실행 컨텍스트에 진입할 때마다 스코프 체인 만들어지며, 스코프 체인은 변수와 함수 검색할 때 쓰인다.
- 함수 컨텍스트는 해당 스코프에 있는 변수, 해당 스코프를 포함하는 컨텍스트에 있는 변수, 전역 컨텍스트에 있는 변수에 모두 접근 가능
- 전역 컨텍스트는 전역 컨텍스트에 있는 변수와 함수에만 접근 가능. 로컬 컨텍스트에 있는 데이터에 직접적 접근 불가능

메모리 관리

- 코스 실행에 필요한 데이터만 유지하는것
- js는 자동으로 가비지 컬렉션을 수행하므로 개발자가 메모리 할당과 회수에 크게 신경 쓸 필요 없다.
- 수동으로 메모리 회수 하고 싶다면 `null` 할당 하여 참조 제거
  - 수동으로 제거해야 할 대상
  + `전역 변수`, `전역 객체 property`
  + 지역변수는 context 빠져 나간 순간 자동으로 참조 제거 된다.
