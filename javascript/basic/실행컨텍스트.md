# 실행 컨텍스트

실행 컨텍스트는 scope, hoisting, this, function, closure 등 동작원리를 담는다.

실행 컨텍스트는 **실행 가능한 코드가 실행되기 위해 필요한 환경** 이다.

- 실행 가능한 코드란 전역, 함수 이다.
- 필요한 환경에는 다음 정보가 담겨있다.
  - 변수(전역, 지역, 매개변수, 객체 프로퍼티)
  - 함수 선언
  - 스코프(변수의 유효범위)
  - this

실행컨텍스트는 언제 만들어질까?

보통 함수가 실행 될 때마다 스택에 실행 컨텍스트가 만들어진다.
함수가 함수를 또 실행하면 실행 컨텍스트에 스택에 또 쌓인다.

## 실행 컨텍스트 생성 과정을 깊게 보자.

먼저 EC는 VO(AO를 가리킨다), ScopeChain, this를 가진다.
AO는 arguments, 변수 정보를 가진다.

```js
function execute(params1, params2) {
  var a = 1,
    b = 2;
  function func() {
    return a + b;
  }
  return param1 + param2 + func();
}
execute(3, 4);
```

- AO(활성 객체) 생성

실행 컨텍스트 생성시 JS 엔진은 해당 컨텍스트가 가진 정보를 담을 객체를 생성한다.

- arguments 객체 생성
- Scope 체인 생성

스코프 체인은 리스트다.
전역 객체(GO) 또는 활성 객체(AO)의 리스트다.
그래서 스코프 체인 생성시, 자신이 생성된 EC의 스코프 체인 위에 현재 활성객체를 추가한다.

> 스코프는 현재 컨텍스트의 유효 범위를 나타낸다.
> 어떤 변수에 접근해야 한다면 이 스코프 정보를 이용한다.
> 이 스코프에서 변수를 찾지 못하면 `참조 에러: 정의되지 않은 변수 접근` 가 발생한다.

- 변수 생성

지역 변수를 생성한다.

위 예제에서 `var a,b` , `function func(){}`를 생성.
**주의할 점은 메모리에 각 변수를 할당 후, 실제 값이 할당되는 건 표현식이 실행되기 전까지 이뤄지지 않음**
**예외는 함수 선언식의 경우 함수 선언식 호이스팅으로 인해(함수 표현식 제외), 함수 객체를 즉시 할당한다.** (그래서 함수 선언식 이전에 호출 가능하다.)
즉, undefined 상태다. (변수 호이스팅. 함수 선언식 호이스팅과 다르다. 값 할당은 EC 생성 후, 코드 실행시 이뤄진다.)

> 표현식의 실행은 EC 생성 및 VO가 만들어진 후에 이뤄진다.
> VO는 AO를 가리킨다.

- this binding
  함수 호출 패턴에 의해 결정된다.

---

이제 VO가 만들어진 후에 EC가 만들어지면 코드 실행 준비가 된거다. 이제, 표현식 실행이 이뤄진다.
변수의 값 할당 및 연산, 함수 실행이 이뤄진다.

## QNA

Q. 실행컨텍스트란?
A. 실행가능한 코드의 정보를 담고 있는 환경이다. 이 때 정보는 변수 객체, 스코프 체인, this에 대한 값이다. 변수 객체는 인자, 해당 EC내의 변수 및 함수다.

Q. 실행 컨텍스트는 언제 만들어지는가?
A. 코드 실행시 전역 컨텍스트가 먼저 스택에 쌓이고, 이훙에 함수 실행시마다 스택에 쌓임.

Q. VO내에서 지역변수 생성시 값까지 할당되는 경우와 아닌 경우가 있는데 설명 가능한가?
A. 함수 선언문은 호이스팅이라는 특징때문에 변수를 메모리에 할당 후, 함수 객체를 즉시 할당한다. 변수 선언(물론 함수표현식 포함)은 변수 호이스팅으로 인해 변수만 메모리에 할당된다. 그래서 undefined 상태다.
(덧붙이자면, 변수가 선언되기 전에 변수를 사용(함수 표현식의 변숭의 경우 호출은 안되는거 알지?)할 수 있는데, 이것은 EC에서 해당 변수를 먼저 메모리에 할당하기 때문이다.)
