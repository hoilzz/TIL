## 2.1.1 통신원리

브리지에 연결된 브로커를 추가하여 네트워크 크기를 증가시킬 수 있는 브로커라는 서버로 구성

각 클라는 브로커에게 자신의 클라 ID를 제공하기 위해 연결되며

브로커는 클라의 연결을 관리하고, 그들 사이의 메시지를 전송한다.

또한 브로커는 디비에 저장하여 모든 메시지의 영속성을 관리하는 책임이 있다.

## 2.2.3 메시지 : publish, subscribe and topic

publish/subscribe 패턴과 topic 개념을 기반으로 MQTT 프로토콜이 구성된다.

클라는 발행자, 구독자 또는 둘 모두가 될 수 있다. 발행자인 경우, topic에 메시지를 발행하고,
구독자인 경우 topic에 등록되어 topic에 게시된 모든 메시지를 수신할 수 있다.

topic은 클라가 메시지를 교환하는 메커니즘이며,

기술적으로는 메시지 큐이고 브로커는 모든 등록을 큐로부터 관리해야 한다.

클라가 발행된 메시지를 수신하는데 관심 있는 항목을 관찰할 수 있기 때문에 이 패턴은 “감시자”로 알려짐

이 모델은 2가지 분배를 허용

1. 일대일
2. 일대다

게시자는 가입자에 대해 알 필요 없음
이런 모든 특징은 클라 비동조화와 비동기 통신을 보장

구독은 영속성 또는 비영속성이 될 수 있다.

- 영속성
  - 브로커가 연결되어 있다면 즉시 등록하고 있는 클라의 메시지를 릴레이
  - 연결 안되있으면 다음 번 구독자 연결 될 때까지 메시지 저장
- 비영속성
  - 브로커는 오직 가입자와 연결되어 있을 때 메싲디를 릴레이
  - 그렇지 않은 경우 메시지 잃음

이러한 선택은 클라가 접속된 메시지에 `clean session flag`를 사용하여 브로커에 연결할 때 이뤄짐
- flag == true
  - 클라와 연결되어 있지 않을 때 모든 클라의 등록은 제거 된다 (비영속성 구독)
- flag == false
  - 클라와 연결이 끊어져도 모든 등록은 활성 상태로 유지 된다. (영구 구독)

  클라가 서버 접속시 예기치 않게 연결 끊어질 경우, 브로커가 특정 topic을 발행해야하는 `will` 메시지 구체화할 수 있다.


## 2.2.4 Topic format

### Topic
Publish와 Subscribe는 topic을 기반으로 동작한다.
topic은 퍼블리셔와 구독자의 메시지의 중앙 유통 허브 역할을 한다.
예를 들어 채팅 프로그램이 Broker라고 하면 채팅방이 Topic, publisher와 subscriber는 사용자가 된다.
MQTT는 Topic으로 하여 세부 그룹화를 나눌 수 있다. 먼저, 다음과 같은 표현방식을 가진다.

- Topic은 문자열로 표현
- 하위 항목의 각 계층은 `/`문자로 구분되는 계층 구조를 가진다.

- 예를 들어, 회사가 각 층과 방을 위한 온도, 습도 등 많은 센서를 가진 건물 내부의 물리적 데이터를 모니터 한다고 가정했을 때 센서 데이터 발행하고 수신하기 위한 항목 구조는 다음과 같다.

```
building/floor1/room1/temperature
building/floor1/room1/humidity
building/floor3/room4/temperature
```

계층 구조는 다음 그림과 같다.
건물-방-바닥을 따라 특정 센서로 끝난다.

발행자는 topic으로만 발행할 수 있지만
구독자는
- topic을 구독하거나
- 또는 그 이상의 topic에 발행된 메시지를 수신할 수 있도록 와일드카드를 사용할 수 있다.

Topic Wildcards는 한 번에 여러개의 topic을 구독할 수 있는 특별한 문자다.

topic level separator는 topic의 구조를 수고하는데 이용된다. 그리고 그 목적에 맞는 topic으로 명시된다. multi-level wildcard와 single-level wildcard는 구독할 때 사용된다. 하지만 두 레벨의 와일드 카드는 message의 발행자는 사용하지 못한다.

Topic level separator
`/`는 topic tree 내에서 레벨을 분리하는데 사용되고 계층 구조를 제공한다. 구독자가 명시한 토픽에서 2개의 wildcard character가 만났을 때, topic level separator는 중요하다.

와일드카드는 2가지 유형이 있다.
- 단일 레벨 와일드카드 `+`는 계층 구조의 **특정 레벨에 대한 하위 항목**
- 멀티 레벨 와일드 카드 `#`은 문자열 끝에만 쓰일 수 있다., **이 계층의 하나 이상의 레벨**을 나타낸다.
  - 예를 들어 `finance/#/closingprice`는 유효하지 않다.
  - `#` 혹은 topic level separator character 다음(`finance/#`)에만 쓰일 수 있다.


위의 예를 고려하는 경우에

1. building1 안의 floor1의 모든 객실의 모든 온도 값은?
- 주제 계층 구조 내부의 객실 수준을 축소하기 위해 `+` 사용 가능

```
  building1/floor1/+/temperature
```

2. building2 내 floor2의 room3의 온도, 습도 등 모든 데이터 센서의 수치는?
- 주제 계층 구조의 마지막 수준을 축소하려면 `#`

```
  building2/floor2/room3/#
```
## 2.2.5
## QoS

2.2.5  QoS
TCP/IP 기반의 MQTT는 데이터 전달을 보장하지만 TCP 연결이 끊어졌을 경우에는 메시지 잃을 수 있다.
모든 통신 프로토콜은 QoS를 보장하고 MQTT는 메시지 전달을 TCP 상위 3계층을 정의한다.
Level0~Level2 까지 서버는 등록자에게 큰 대역폭 소비와 대기시간이 존재하지만 높은 QoS를 전달해주는 메시지 보장하기 위해 노력을 기울인다.

QoS Level0(거의한번)
- 이경우MQTT 어떤기능 도 TCP에 추가하지 않는다. 그래서 이 레벨은 TCP의 “best-effort”와 같다. 메시지는 목적지에 도달하거나 도달하지 못한다.

QoS Level 1 적어도 한 번
- 메시지가 등록자에게 도착하는 것을 보장하지만 중복이 있을 수 있다. 클라는 한 번 또는 그 이상 메시지를 받을 수 있다.

QoS 레벨 2 정확히 한 번
- 등록자에게 정확히 한 번 전달된다. 이 경우 최대 오버헤드가 발생하고 브로커는 메시지를 로컬로 저장
