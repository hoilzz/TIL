# http

http/1.1은 커넥션당 1개의 요청을 처리하도록 설계되어있다. 그래서 **동시 전송 불가, 요청과 응답이 순차적**으로 이뤄진다. 그래서 다수의 리소스(img, css, js)를 처리하려면 요청할 리소스 개수에 비례하여 Latency(대기시간)이 길어진다.

HOL Blocking : 특정 응답의 지연

## HTTP의 HOL Blocking

## HTTP/1.x의 커넥션 관리

대규모로 커넥션을 열고 유지하는 것은 웹 어플르케이션 성능에 영향을 준다. HTTP/1.x에는 몇 가지 모델이 존재한다.


### 단기 커넥션

HTTP/1.0의 기본 커넥션은 단기 커넥션.

TCP handshake 자체는 시간 소모적이다. 하지만 TCP 연결은 부하에 적응하여 더 지속된 연결로 효율적으로 된다. Short-lived 연결은 TCP의 특징인 효율성을 사용하지 않고 새로운 cold connection을 통해 지속적으로 전송함으로써 퍼포먼스는 최적상태에서 저하된다.

1.0 모델은 Connection 헤더가 존재하지 않거나 값이 close로 설저오디어있다. 

> Connection 헤더는 전송 완료 후 네트워크 접속을 유지할지 말지 제어한다. 만약 전송된 값이 `keep-alive`면 연결은 지속되고 끊기지 않으며 동일 서버에 후속 요청 수행 가능하다.


### 영속적인 커넥션

단기 커넥션의 두 가지 결점

1. 새로운 연결 시간 소모 큼
2. TCP연결의 퍼포먼스가 커넥션이 일정 시간 동안 사용된 경우에만 더 나아진다.

위 문제를 완화하기 위해, HTTP/1.1보다도 앞서 영속적인 커넥션 컨셉이 만들어졌다. **keep-alive 커넥션**이다.

얼마 동안 연결을 열어놓고 여러 요청에 재사용하여, TCP 핸드쉐이크 비용을 아끼고, TCP 성능 향상 기능을 활용할 수 있다. 커녁센은 영원히 열려있지 않고 얼마 후에 닫힌다.(`keep-alive` 헤더를 통해 최소 얼마동안 열려 있어야 할지 설정 가능하다.)

물론 단점이 있다. 유휴 상태일 때도 서버 리소스를 소비하며 과부하 상태에서는 Dos attacks을 당할 수 있다. 이런 경우 커넥션이 유휴 상태가 되자마자 닫히는 비영속적 커넥션이 더 나을 수 있다. 

HTTP/1.0은 기본적으로 영속적이지 않다. `Connection`을 `close`가 아닌 다른 것으로 `retry-after`로 설정시 영속적 동작

반면, **HTTP/1.1에서는 영속적이며 헤더도 필요하지 않다.**