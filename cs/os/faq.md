# faq

## 스레드

- 프로그램 내에서 여러 개의 실행 흐름을 두기 위함
- 사람을 프로세서로(실행 중인 프로그램)
- 각 독립적인 일의 단위를 스레드라고 함
- 즉 하나의 프로세서에서 병렬적으로 여러 개 작업을 처리하기 위해 각 작업을 스레드화 하여 멀티스레딩이 가능하게 함

> ex. 워드 사용시
>
> - 글자 입력하면서
> - 파일을 주기적으로 자동저장
> - 입력하는 동안 맞춤법도 검사
>   이 모든 작업들은 각 스레드에 의해서 이뤄짐. 즉, 워드라는 큰 프로세스 안에 여러 개의 스레드가 있음

**이점**

- 한 번에 하나의 일을 처리하는 것이 아닌 동시에 많은 일 처리 가능
- 같은 일을 더 빠른 시간 내에 처리 가능

## 멀티 프로세스

- 부모-자식 관계여도 자신만의 메모리 영역 가짐
- fork 를 통해 프로세스 복사
- 프로세스 간 통신 하려면 IPC(Inter Process Communication: 세마포어, 큐, 공유메모리)

```
  부모프로세스
| code 영역  |  -> 똑같이 생긴 영역 생성
| Data 영역  |
| Heap 영역  |
| stack 영역 |
```

## 멀티 스레드

- 1 개의 프로세스가 다수 개의 작업을 각각 스레드를 이용하여 동시 작동 가능
- 스레드는 다음과 같은 공유 메모리 가짐

![img](https://t1.daumcdn.net/cfile/tistory/217D00505822F78905)

### 비교

멀티 프로세스와 비교하여 멀티스레드가 가지는 이점
- 컨텍스트 스위칭시에 공유 메모리 만큼 시간 손실 감소
    - 프로세스 간 컨텍스트 스위칭시 단순히 CPU 레지스터 교체 뿐 아니라 RAM과 CPU 사이의 캐쉬메모리에 대한 데이터까지 초기화됨.
    - __Stack을 제외한 모든 메모리를 공유__ 하기 때문에 global(전역), static(정적) 변수 그리고 new, malloc에 의한 모든 자료를 공유할 수가 있다.

계산기와 메모장처럼 서로 완전히 별개의 프로그램이면 별개의 프로세스 구성,
서로 관련된 기능들은 멀티스레드로 구현하는게 이득

__공유할 때 생기는 문제__
- critical section기법으로 해결

## 컨텍스트 스위칭

CPU가 어떤 프로세스 실행 중인데, 인터럽트 요청에 의해 다음 우선순위의 프로세스 실행 될 때,
- 레지스터 값(Context) 저장하고
- CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 레지스터 값(Context)교체하는 작업
    - context switching시에 CPU는 아무 일도 못함. 그래서 컨텍스트 스위칭이 잦아지면 오버헤드 발생

## critical section

하나의 스레드가 공유데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽기 시도하면 예측 불가능한 결과
__그래서 공유데이터의 접근에 동기화 필요__

임계 구역 문제 해결하기 위한 요구 조건

1. 상호 배제
    - 1개의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행 불가
2. 진행
    - 임계 구역에서 실행되고 있는 프로세스가 없을 경우, 들어갈 프로세스를 적절히 선택
3. 한정된 대기
    - 프로세스 기아를 방지하기 위해, 한 번 임계구역에서 실행된 프로세스는 다음 실행시 제한

## 뮤텍스와 세마포어

둘 다 커널 자원에서의 동기화 서비스로 제공됨.

> 생산자 스레드는 데이터를 모으고 버퍼에 씀
> 구매자 스레드는 버퍼로부터 데이터를 모음
> 두 스레드는 동시에 실행 불가

이 문제의 해결방안은?

뮤텍스
- 상호배제 제공
- 생산자(p) 혹은 구매자(c)는 뮤텍스를 가지고 일을 진행
- p로 인해 버퍼를 채운다면 c는 기다려야함 (반대도 동일)
- 그 결과 어느시점에서든 오직 1개의 스레드만이 전체 버퍼에서 일할 수 있음

세마포어
- 일반화된 뮤텍스
- 4kb 버퍼를 4개의 1kb로 분리 가능
- 분리된 4개의 버퍼에 각 세마포어 할당 가능
- c와 p는 동시에 다른 버퍼에서 일할 수 있음

뮤텍스는 Bool, 세마포어는 int다.
바이너리 세마포어는 0,1만 사용하기에 bool이다. 

__하지만 뮤텍스와 세마포어는 목적이 다르다.__

- __뮤텍스는 자원의 접근에 있어 동기화할 경우 `locking` 사용__
    - 오직 1개의 일(스레드, 프로세스)이 뮤텍스 가질 수 있음
    - 즉, 할당된 뮤텍스를 소유할 수 있다는 것이므로 오직 소유자만이 락을 해제할 수 있음

- __세마포어는 (나 일 끝냈어. 너가 이제 써)와 같은 `시그널` 사용__
    - 핸드폰으로 노래 듣는데 친구한테 전화옴
    - 이 시점에서 인터럽트는 인터럽트 서비스 루틴이 전화 프로세스가 호출되도록 신호 주면서 발생

> 뮤텍스는 한 번 이상 잠금 가능?
가능하다. 해제할 경우 잠근 수만큼 해제해야함

반복적이지 않은 뮤텍스에 한 번이상 잠금 걸리면?
데드락 초래. 뮤텍스는 소유자만이 해제 가능.
잠금이 풀리지 않은 상태라면, 다른 스레드에서 해헤 불가능하니까 무한정 대기


## 스핀락

만약 다른 스레드가 lock
