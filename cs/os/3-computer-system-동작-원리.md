# ch 3 컴퓨터 시스템의 동작 원리

## 인터럽트 서비스 루틴

프로그램은 여러개의 함수로 구성된다. 메모리 주소를 조사해보면

- 코드
- 데이터
- 스택 등의 영역으로 나뉨

_스택_

- 실행 중인 함수에서 다른 함수 호출한 경우, 함수 종료 후 실행한 함수 위치로 돌아가기 위해 **복귀 주소 저장**

_데이터_

- 전역 변수 등 프로그램이 사용하는 각종 데이터가 저장되는 공간

_코드_

- 작성한 코드가 기계어 형태로 저장되는 영역
- CPU 는 매 시점 코드 부분에 있는 명령을 하나씩 읽어와서 수행

## 인터럽트 핸들링

인터럽트가 발생한 후에 처리해야 할 절차

- CPU 에서 명령어 수행시 CPU 내부의 임시 기억장치인 레지스터에서 데이터를 읽거나 쓰면서 작업 수행
- 인터럽트 발생시, 이것을 CPU 내의 하드웨어에 상태 저장

### PCB(Process Control Block)

- 이 부분에 저장되는 내용은 현재 수행 중인 메모리 주소, 레지스터 값, 하드웨어 상태 등이 있음
- 이 정보가 저장된 후, 인터럽트 수행 끝나면 저장된 값을 CPU 상에 다시 복원해 인터럽트 당하기 직전의 명령 계속 수행

## 3.5 입출력 구조

입출력이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고 받는것

2 가지 방식 있음

1. 동기식 입출력
2. 비동기식 입출력

### 동기식 입출력

- 입출력 요청한 프로그램은 입출력 완료될 때까지 다음 명령 수행 못해서(`blocked state`) CPU 낭비 초래
- CPU 의 효율적인 사용을 위해 입출력 수행되는 동안 다른 프로그램에게 CPU 를 양도
- 이로인해, 동시에 다수 입출력 연산 일어날 수 있음
- A 라는 프로그램이 입출력 요청하여 수행 중에 프로그램 B 가 입출력 연산 요청시 또다른 입출력 연산 일어나기 때문
  - A 가 디스크의 파일 내용 1-> 3 으로 바꾸는 입출력 연산 요청
  - B 는 A 가 쓰던 CPU 할당 받고, A 가 입출력 요청한 곳과 동일한 파일의 내용 1 증가 시키는 내용
  - 매 시점 2 개 이상의 입출력 연산 수행 가능하다면, A 와 B 의 순서를 바꾸어 수행 가능. 그러면 `1->3->4`가 아닌 `1->2->3`이 된다.
- 위와 같은 `Sync(동기성)`를 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리

### 비동기식 입출력

동기식과 차이점

- CPU 의 제어권을 입출력을 요청한 프로세스에게 곧바로 다시 주어짐
- 입출력 연산이 완료된는 것과 무관하게 처리 가능한 작업 부터 처리

동기식과 공통점

- 입출력 연산 완료시 동기식과 마찬가지로 인터럽트를 통해 이를 CPU 에게 알려주게 됨
- 그러면 그 시점부터 읽어온 데이터를 필요로 하는 명령 수행

## 3.6 DMA(Direct Memory Access)

- 메모리는 CPU 에 의해서만 접근 가능한 장치
- 주변 장치들이 메모리에 접근하기 위해 CPU 에게 인터럽트 발생시켜 CPU 가 일을 대행

  - 예를 들어, 컨트롤러가 CPU 에게 인터럽트 발생시
  - CPU 는 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨주는 일을 함

- 근데 모든 메모리 접근 연산이 CPU 에 의해서만 이루어질 경우 주변 장치가 메모리 접근 원할 때마다 인터럽트를 통해 CPU 의 업무 방해로 인해 CPU 사용 효율성 떨어짐

- DMA: 그래서 CPU 이외에 메모리 접근 가능한 장치 하나 더둠
  - 일종의 컨트롤러
  - CPU 가 주변 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 커버쳐줌
  - DMA 사용시 로컬 버퍼에서 메모리 읽어오는 작업을 DMA 가 대행
  - CPU 는 원래 하던 작업 멈추고 인터럽트 처리할 필요가 없음
  - 이 때, DMA 는 바이트 단위가 아닌 블록이라는 큰 단위로 메모리를 읽어와서 CPU 에게 인터럽트 발생 시켜 해당 작업 완료 알림

## 3.7 저장장치의 구조

### 보조기억장치

- 비휘발성, CD, 플래시 메모리 등

2 가지 용도

1. file system 용
   - 전원이 나가도 유지해야 할 정보가 있으면 파일 형태로 저장
2. 메모리의 연장 공간인 **swap area**
   - 메모리는 크기가 한정되고 가격이 상대적으로 비싸고 용량이 적은 경우가 대부분
   - 다수의 프로그램이 메모리에 올라가 동시에 수행하는 현대 환경에서 메모리 공간 부족한 경우 흔히 발생
   - 이 경우 OS 는 프로그램 수행에 당장 필요한 부분만 메모리에 올리고 그렇지 않은 부분은 **swap out**시킴
   - swap out 된 부분이 필요하면 다시 메모리 영역으로 올림
   - 실행 중인 프로그램을 내려놓는 swap area 는 보통 HDD 가 널리 사용

## 3.8 저장장치 계층 구조

컴퓨터 시스템을 구성하는 저장 장치는 빠른 저장 장치 부터 느린 저장 장치까지 단계적 계층 구조로 구성

- 빠른거 : 공간당 가격 높기 때문에 적은 용량
- 느린거 : 가격 저렴이, 대용량 사용 반면 접근속도 느리다는 약점

```
// primary
registers
cachememory
mainmemory
------
// secondary
magnetic disk
optical disk
magnetic tape
```

상위로 갈수록

- 접근 속도가 빠르지만 용량 적음
- 하지만 **당장 필요한 정보만을 선별적으로 저장** 하면 하위에 있는 큰 용량의 저장장치를 가지고 있는 것과 비슷한 효과 낼 수 있음
- 캐쉬 메모리는 레지스터와 메인 메모리 사이에 존재하며 캐슁 기법을 이용해 적은 용량의 캐쉬 메모리로도 메인 메모리와 같은 용량을 가진 것처럼 효율적 사용
  - 캐슁 기법은 걍 빈번히 사용 or 연산되는거 캐싱하는거

## 3.9 하드웨어 보안

다중 프로그래밍 환경에서는 여러 프로그램이 동시 실행됨.

- 각 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌을 일으키는 문제를 막기 위해 보안 기법 필요

이를 위해 OS 는 2 가지 모드의 오퍼레이션 지원

1. 커널 모드
2. 사용자 모드

어떤 프로그램이 이상한 명령을 수행하여 다른 프로그램의 메모리 영역이나 파일 영역 침범할 수 있음.

- 따라서 중요한 정보에 접근해 위험한 상황 초래할 수 있는 연산은 커널에서만 가능

### 커널 모드

OS 가 CPU 의 제어권을 가지고 OS 코드를 실행

- 모든 종류의 명령어 실행 가능

### 사용자 모드

- 제한적인 명령 수행

근데 중요한 연산을 OS 만이 수행할 수 있도록 하더라도 사용자 프로그램이 프로그램 내에서 그런 종류의 연산을 수행하면 제어가 아무 소용이 없음. -> 사용자 프로그램이 CPU 를 가지고 있는 동안 OS 가 CPU 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법 없음

위와 같은 상황을 방지하기 위해 **하드웨어적 지원** 필요

컴퓨터 시스템은 CPU 내부에 mode bit 를 두고 사용자를 감시할 수 있음.

- 모드 비트가 0 이면 커널 모드로써 모든 명령 수행 가능
- 모드 비트가 1 이면 사용자 모드로써 제한된 명령 수행 가능
  - 예컨대, OS 가 CPU 점유하여 자기 코드 수행하다가 사용자 프로그램에게 CPU 제어권 넘길 때 모드 비트를 1 로 설정하고 넘김.

_그럼 사용자 프로그램이 하드웨어 접근 등 보안이 필요한 중요한 명령어 수행이 필요할 경우?_

- 시스템 콜을 통해 OS 에게 서비스를 대신해줄 것을 요청.

```
            interrupt / system call / exception
Kernel mode <----------------------------------- user mode
            ----------------------------------->
                     return to user mode
```

## 3.10 메모리 보안

사용자 프로그램 A 가 B 사용자 프로그램이나 OS 가 우치한 메모리 영역 침범 가능

해결책은 **2 개의 레지스터를 두는 것**

1. 기준 레지스터
2. 한계 레지스터

### 기준 레지스터

어떤 프로그램이 수행되는 동안 합법적으로 접근 가능한 메모리 상의 가장 작은 주소 보관

### 한계 레지스터

해당 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위 보관

즉,
기준 레지스터: 어떤 프로그램이 실제 메모리에 올라가 있는 부분의 시작 주소
한계 레지스터: 그 프로그램의 길이

그래서 메모리 접근 연산 있을 때마다 하드웨어적으로 현재 접근하려는 위치가 합법적인 범위인지 체크

- 이 때 불법적인 메모리 접근은 **Exception** 이라는 소프트웨어적인 **interrupt** 발생
- 인터럽트가 발생했으므로 CPU 제어권을 해당 프로그램에서 OS 로 이양, 그리고 OS 는 예외를 발생시킨 프로그램 강제 종료시킴

> 메모리 접근 연산은 사용자 프로그램이 CPU 가지고 있는 동안 수행할 수 있는 연산이므로 특권은 아님
> 다만, 사용자 프로그램이 메모리 접근하기 전에 하드웨어적으로 접근이 합법적인지 체크하여 메모리 보호
> 이것이 OS 만이 수행할 수 있는 입출력 연산과 메모리 접근 연산 차이점

## 보안에 관한 Summary

메모리 보안 - 사용자 모드인 경우 기준 레지스터와 한계 레지스터를 사용하여 메모리 보호. - 커널 모드에서는 메모리에 무제한 접근 가능.

하드웨어 보안 - 2 가지 모드로 나눠서 명령어 수행 접근 범위 나눔 - 커널 모드: 모든 명령어 수행 - 사용자 모드: 제한 명령어 수행 - 한계: 사용자 모드에서 CPU 주도권을 갖고 이상한 명령어 수행하는 것을 OS 가 감시할 수 없음(OS 가 CPU 주도권 갖고 있지 않아서) - 해결책: 컴퓨터 내부에 mode bit 를 두고 사용자 감시 - 모드비트 0 이면 커널 모드로써 모든 명령 수행 가능 - 1 이면 제한된 명령 수행. - **혹시나 보안이 필요한 중요한 명령어 수행할 경우 시스템 콜을 통해 OS 에게 서비스 대신 해달라고 요청**

## 3.11 CPU 보호

특정 프로그램이 CPU를 독점하여 무한 반복문 수행하는 등 CPU  독점할 수 있음.
- 해결책; 타이머라는 하드웨어 사용
    - 정해진 시간이 지나면 인터럽트 발생 시켜 OS에게 CPU의 제어권을 이양시키는 역할.


## 3.12 시스템 콜을 이용한 입출력 수행

특권 명령인 입출력 명령은 사용자 프로그램이 직접 수행 불가
- 사용자 프로그램이 디스크의 파일에 데이터 쓰기, 
- 디스크의 파일로부터 데이터 읽어오기 등 
- 키보드 입력, 수행 결과 모니터 출력

__시스템 콜__ 이라는 서비스 대행 요청하여 입출력 수행 하도록 함.
- 시스템 콜은 소프트웨어 인터럽트로, 발새앟ㄹ 경우 CPU에 대한 제어권이 운체로 넘어감    '
