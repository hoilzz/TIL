# Redux : 배경지식 | MVC, FULX
flux 아키텍처를 구현할 라이브러리.
- component들끼리 데이터 교류 및 state 관리를 쉽고 효율적으로 할 수 있는 라이브러리

## flux
- 일종의 아이디어. 라이브러리나 프레임워크가 아니다. 추상적인 개념
- 이 개념을 구현할 게 Redux

## MVC 알아보자
문제점
- 어떤 모델이 view를 건드리고 또 그 뷰가 어떤 모델 건드리고.. 무한반복이 됨
- 페북 사례
  - 읽지 않는 chat 개수

## flux
- 시스템에서 action 받았을 때 dispatcher가 받은 action을 통제하여 store에 있는 데이터를 업데이트 , 그리고 변경된 데이터가 있으면 view에서 리 렌더링.
- 그리고 view에서 store 직접 접근 안함. view에서 dispatcher로 action을 보냄
- dispathcer는 작업이 중첩되지 않도록 함
- 즉, 어떠 action이 디스패처를 통하여 스토어에 있는 데이터를 처리하고
- 그 작업이 끝날때까지 여기서 action을 대기시킴

### 캐릭터로 설명
#### action 설명자
- action은 앱에서 어떤 부분이 업데이트되어야하는지 정의
- action 생성자는 전보기사처럼 어떤 걸 업데이트해야하는지 갖다주면 action 형태로 변환하여 dispatcher가 알아들 을 수 있도록 함

#### 디스패처
- 교환원과 같다
- action 받으면 action을 읽고 어떤 부분 업데이트할지 정한다
- 동기적으로 실행된다
- 여러 액션 들어오면 우선권 가진 액션을 먼저 처리
- 그래서 꼬이지 않는다

#### store
- 정부관료와 같다
- 모든 상태와 관련된 로직을 가지고 있다

#### view
- 발표자
- application 내부에 대해 아는거는 없지만 사람들이 이해할 수 있는 HTML로 바꿀 수 있다.


### action creator (aka 전보기사)
메시지를 포맷에 맞게 변환시킨다
- 모든 변경사항과 사용자와의 상호작용이 거쳐가야 하는 액션의 생성을 담당하고 있다.
- 언제든 앱 상태를 변경하거나 뷰를 업데이트하고 싶다면 액션 생성해야 한다.
- 무슨 메시지를 보낼지 알려 주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷으로 바꾼다 (전보기사가 알파벳을 기계들이 처리할 수 있는 모스부호로 바꾸는 것처럼)
- type과 payload를 포함한 액션을 생성
  - `payload??`
  - type은 시스템에 정의된 액션들(상수들) 중 하나다
  - 그 예로는 MESSAGE_CREATE나 MESSAGE_READ같은 것들이 있다.
- 모든 가능한 액션들을 아는 시스템을 가짐으로써 부차적으로 갖는 멋진 효과
  - 새로운 개발자가 프로젝트에 들어와서 행동 생성자 파일을 열면 시스템에서 제공하는 API전체(모든 가능한 상태변경)를 확인할 수 있다.
- 액션생성자가 액션 메시지 생성한 뒤에 dispatcher에게 넘긴다

### dispatcher
콜백이 등록되어 있는 곳
- 전화 교환대에서 교환원이 일하는 것
- 디스패처는 액션을 보낼 필요가 있는 모든 store를 가진다
- 액션 생성자로부터 액션이 넘어오면 여러 스토어에 액션을 보낸다.
- 동기적으로 실행
  - 스토어들 사이에 의존성이 있어서 하나를 다른 것보다 먼저 업데이트해야한다면, waitFor()를 사용해서 디스패쳐가 적절히 처리하도록 할 수 있다.
- flux의 디스패처는 다른 아키텍처들과는 다른 점이 있다.
  - 액션 타입과 관계없이 등록된 모든 스토어로 보내진다
  - 즉, 스토어가 특정 액션만 구독하지 않고 모든 액션을 일단 받은 뒤 처리할지 말지 결정

### store (aka 정부관료)
모든 것을 관리하는 정부관료. 모든 변경사항은 이곳을 지나가야 한다
- 스토어는 `애플리케이션내의 모든 상태`와 `그와 관련된 로직`을 가지고 있다.
- 모든 상태 변경은 반드시 스토어에 의해서 결정되어야 하며, 상태 변경을 위한 요청을 스토어에 직접 보낼 순 없다.
- setter가 존재하지 않으므로, 상태 변경을 위해서는 반드시 모든 정해진 절차를 따라야 한다.
  - 즉, **무조건 액션 생성자/디스패처 파이프라인을 거쳐서 액션 보내야 한다.**
- 스토어가 디스패처에 등록되어 있다면, 모든 액션을 받게 된다.
- 스토어의 내부에서 보통 switch 문을 사용해서 처리할 액션과 무시할 액션을 결정한다.
- 만약 처리가 필요한 액션이라면, 주어진 액션에 따라 무엇을 할 지 결정하고 상태를 변경하게 된다
- 스토어에 상태 변경을 완료하고 나면, 변경 이벤트를 내보낸다.
  - 이 이벤트는 컨트롤러 뷰에 상태가 변경했다는 것을 알려준다

### controller and view (aka 발표자)
컨트롤러 뷰는 스토어로부터 알림을 받고 자신 아래의 뷰로 전달해주는 중간관리자
뷰는 가지고 있는 데이터를 사용자에게 보여준다
- 뷰는 상태를 가져오고 유저에게 보여주고 입력받ㅇ를 화면을 렌더링하는 역할
- 애플리케이션 내부에 대해 아는 것이 없지만, 받은 데이터를 처리해서 사람들이 이해할 수 있는 포맷(HTML)으로 어떻게 바꾸는지 알고 있다.
- 컨트롤러 뷰는 스토어와 뷰 사이의 중간관리자 같은 역할을 한다.
- 상태가 변경되었을 때 스토어가 그 사실을 컨트롤러 뷰에게 알려주면, 컨트롤러 뷰는 자신의 아래에 있는 모든 뷰에게 새로운 상태를 넘겨준다.
