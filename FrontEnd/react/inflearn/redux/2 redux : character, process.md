# Redux : 특징과 흐름
각 노드들은 컴포넌트다. 컴포넌트들은 스토어에 데이터를 담고,
- 빨간 화살표는 dispatch, 즉 스토어에 있는 데이터를 업데이트
- 주황색 화살표는 subscribe, 예를들어 빨강 컴포넌트에서 초록색 컴포넌트로 데이터 교류 필요할 시 redux가 없다면 parent parent 엄청 올라가야함
- 근데 redux 있다면 store에 보내고 subscribe한 컴포넌트들에게 바로 반영

## 3가지 특징
1. Single Source of Truth
  - 어플리케이션의 state를 위해 단 한개의 store를 사용
  - flux와의 주요 차이 : 여러개의 store 사용
  - store의 데이터 구조는 개발자 하기 나름
  - 보통 매우 nested됨
  - 이 구조를 컴포넌트 별, 이벤트 별로 구조화 시킬 수 있음
  - 앱의 데이터 다루기, 컴포넌트 UI상태를 다루는 것으루 따로따로 구조화 가능 맘대로 가능
2. State is Read-only
  - 앱에서 store의 state를 직접 변경할 수 없다
  - state를 변경하기 위해 무조건 action이 dispatch 되어야 합니다.
  - redux 매뉴얼 , state를 바꾸는 유일한 방법은 어떠한 일이 발생해쓴ㄴ지 나타내주는 action개체를 전달하는 것
  - 즉, 어플리케이션에서 state를 직접 변경 불가능
  - state변경하기 위해 action이 dispatch되야함
3. Changes are made with pure functions
  - action 객체를 처리하는 함수를 reducer라고 부른다
  - reducer는 정보를 받아서 상태를 어떻게 업데이트할지 정의
    - 순수함수로 작성되야함 (비동기 처리 ㄴㄴ)
    - 즉, 네트워크 및 db 접근 X, 인수 변경 X
    - 같은 인수로 실행된 함수는 언제나 같은 결과를 반환
    - `순수하지 않은` API 사용 불가(Date.now(), Math.random());

## Redux로의 카툰 안내서
Flux에서 영감을 받아 만들어진 Redux와의 차이점이 넘나 혼란..

### 왜 Flux를 바꿔야하나?
Redux는 Flux가 해결하는 문제점에다가 추가적인 문제점 해결 가능.

Flux와 같이 Redux도 애플리케이션의 상태를 더욱 예측 가능하게 만든다.
- 만약에 상태를 변경하고 싶다면 액션 발생시켜야 한다.
  - 상태를 저장하고 있는 store는 getter만 있고 setter는 없다.
  - 그래서 직접적으로 상태를 바꿀 방법이 존재하지 않는다.
- 이러한 기본적인 점은 Flux와 Redux는 비슷

그럼 왜 다른 패턴이 필요할까?
- 더 나은 개발자 도구 사용하기
- hot reloading, 시간 여행 디버깅을 원했지만 Flux로 처리하기에는 어려운 몇몇 문제점이 있다

### 문제점 1 스토어의 코드는 애플리케이션 상태를 삭제하지 않고는 리로딩이 불가능하다.
Flux에서 스토어는 다음의 두 가지를 표현
1. 상태 변환을 위한 로직
2. 현재 애플리케이션 상태

스토어 객체 하나가 이 두가지를 가지고 있는 것은 `핫 리로딩`을 할 때 문제점을 만든다.
- `새로운 상태 변환 로직(state change logic)`을 위해 스토어 객체를 리로딩하면
  - 스토어에 저장되어 있는 기존의 상태까지 잃어버림
  - 스토어와 시스템의 나머지 부분 사이에 있는 `이벤트 구독(event subscription)`까지 망가진다.

### 해결방법
두 기능을 분리하자.
- 한 객체는 애플리케이션 상태만들 가지게 하고
  - 이 객체는 리로딩하지 않도록 하자
- 또 다른 객체는 모든 상태 변환 로직을 가지도록 하자.
  - 상태를 가지고 있지 않으므로 걱정없이 리로딩 가능.

### 문제점 2 애플리케이션 상태는 매 액션마다 재기록된다
- 시간여행, 디버깅위해서는 상태 객체의 모든 버전들을 기록해두어야 한다. 그걸 가지고 쉽게 이전 상태로 돌아갈 수 있다.
- 매번 상태가 새로 바뀔 때마다 이전 애플리케이션 상태를 상태 객체의 버전들을 저장하는 배열에 추가할 필요 있다.
- 하지만 JS 동작 방식 때문에 단순히 상태를 가진 변수를 배열에다가 추가하는 것만으로 부족하다.
- 이 방식으로는 애플리케이션 상태의 스냅샷을 생성하는게 아니라 같은 객체를 가리키는 새로운 포인터를 만들 뿐이다.

제대로 동작하게 만들기 위해, 각각의 버전이 완벽히 독립된 객체가 될 필요가 있다. 그러면 이전 상태들이 실수로 수정되는 일은 일어나지 않는다.

### 해결방법
액션이 스토어로 전달되었을 때 기존의 애플리케이션 상태를 수정하는 대신, 그 상태를 복사한 뒤 복사본을 수정

### 문제점 3 서드파티 플러그인이 들어갈 좋은 장소가 없다
개발자 도구는 여러 곳에 쉽게 쓰일 수 있도록 만들어야 한다.
- 사용자는 자신의 코드를 수정하지 않고도 간단히 코드 몇 줄 집어넣는 것만으로 개발자 도구를 사용할 수 있어야 한다.
- 이렇게 하기 위해 기존 코드에서 서드파티 플러그인을 추가할 수 있는 장소인 확장점이 필요하다.
- 관련 예제 중 하나로는 로깅(logging)이 있다.
  - 매 액션마다 console.log를 실행한다고 가정해보면,
  - 액션이 들어왔을 때 그 액션의 결과로서 만들어지는 새로운 상태를 로깅할 것이다.
  - Flux에서는 디스패쳐의 업데이트와 각 스토어의 업데이트를 구독해야만 한다
  - 하지만 이것은 서드파티 모듈이 쉽게할 수 있는 것이 아니다.

### 해결방법
시스템의 부분을 다른 객체들로 쉽게 감쌀 수 있게 만들어보자.
- 이 객체들은 약간의 추가 기능들을 시스템의 부분에 추가한다.
- 이런 확장점(extension point)을 enhancer 또는 higher order 객체 혹은 미들웨어라고 부르는 것을 알 수 있다.

또한, 상태 변환 로직(state change logic)을 트리를 사용해서 구조화하자.
- 상태가 변했다는 것을 뷰에게 알리기 위해 스토어는 단 하나의 이벤트만 보내면 된다
- 이 이벤트는 모든 상태 트리가 처리 된 뒤에 보낸다.


## 새로운 캐릭터들
### 액션 생성자
전보기사와 비슷
- 어떤 메시지를 보내고 싶은지 액션 생성자에게 알려주면 나머지 시스템이 이해할 수 있는 포맷으로 변경
- 포맷을 바꾼 뒤 액션을 돌려줌
- **애플리케이션 상태를 바꾸고 싶다면 항상 액션을 보내라**(유일한 방법)

### dispathcer
없어짐

### 스토어
모든 것을 관리하는 정부 관료
- 모든 상태 변화는 스토어가 한다
  - 상태 변화를 스토어에 직접 요청하는게 아닌 액션 파이프라인을 따라야 한다
- Flux와 다른점
  - Redux : **단 하나의 스토어를**를 가지기 때문에 일을 다른 곳에 위임
  + Flux  : 다수의 스토어
    + 각자의 범위를 가지고 내부의 모든 컨트롤을 가진다.
- 상태트리 전체를 유지
  - 액션이 들어왔을 떄 어떤 상태 변화가 필요한지에 대한 일은 위임(리듀서가 함)
  - 디스패처 일을 스토어가 바등

### 리듀서
서류 복사에 지나치게 열성적인 사무실 직원
- 스토어는 액션이 어떤 상태 변화를 만드는지 알 필요가 있을 때 리듀서에게 묻는다
- 루트 리듀서
  + 애플리케이션 상태 객체의 key를 기준 삼아 상태를 조각조각 나눈다.
  + 나뉘어진 상태 조각은 처리할 줄 아는 리듀서로 전달
- 리듀서
  + 일을 망치는 것에 아주 민감하므로 넘겨받은 예전 상태 변경하지 않음
  + 대신 새로운 복사본을 만든 후 거기에다가 모든 변경사항 적용
- 위 두가지가 리덕스의 키 아이디어
  - 상태 객체는 직접 변경되지 않고, 각각의 상태 조각이 복사 후 새로운 상태 객체 하나로 합쳐진다.
  - 리듀서는 복사되고 업데이트된 상태 객체를 루트 리듀서에게 전달,
  - 루트 리듀서는 이 객체를 스토어로 보낸다.
  - 그리고 스토어는 이 객체를 새로운 애플리케이션 상태로 만듬
- Flux는 스토어가 서로 연결될 필요도 없고 수평적 구조를 가졌다
- 반면 redux는 리듀서가 트리 모양의 계급구조 안에 존재
  - 이 구조는 컴포넌트 구조처럼 필요한 만큼의 레벨(트리 높이)을 얼마든지 가질 수 있다

### 뷰 (smart and dump component)
flux는 컨트롤러 뷰와 일반 뷰를 가지고 있다
컨트롤러 뷰는 관리자 같아서 스토어와 자식 뷰 사이에서 커뮤니케이션 관리
  - 영민한 컴포넌트는 액션 처리를 책임진다.
  - 영민한 컴포넌트 밑의 우직한 컴포넌트가 액션을 보낼 필요가 있을 때, 영민한 컴포넌트는 props를 통해서 우직한 컴포넌트에 함수를 보낸다.
  - 영민한 컴포넌트는 자기 자신의 css style을 가지지 않는다
  - 영민한 컴포넌트는 자신의 dom을 거의 가지지 않는다.
    - 대신, dom 요소를 관리하는 우직한 컴포넌트들을 관리한다
  - 우직한 컴포넌트는 액션에 직접 의존성을 갖지 않는다.
    - 이는 모든 액션을 props를 통해서 넘겨 받기 때문이다
    - 즉, 우직한 컴포넌트는 다른 로직을 가진 다른 애플리케이션에서 재사용될 수 있다는 뜻이다.

### 뷰 레이어 바인딩
뷰 트리(view tree)를 위한 IT 부서
스토어를 뷰에 연결하기 위해 Redux는 도움이 필요하다. 그 둘을 묶어 주는 역할
- 모든 컴포넌트를 스토어에 연결하는 역할
- 많은 기술적인 세부사항들을 처리해서 트리 구조가 세부사항에 신경쓰지 않도록 한다
뷰 레이어 바인딩의 3가지 컨셉
1. 공급 컴포넌트 : 컴포넌트 트리를 감싸는 컴포넌트
  - `connect()`를 이용해 루트 컴포넌트 밑의 컴포넌트들이 스토어에 연결되기 쉽게 만들어줌
2. `connect()` : react-redux가 제공하는 함수
  - 컴포넌트가 애플리케이션 상태 업데이트를 받고 싶으면 `connect()`를 이용해 컴포넌트 감싸기
  - 그러면 `connect()`가 셀렉터를 이용해 필요한 모든 연결 만들어줌
3. 셀렉터 : 직접 만들어야 하는 함수
  - 애플리케이션 안의 어느 부분이 컴포넌트에 props로써 필요한 것인지 지정

### 루트 컴포넌트
모든 React 애플리케이션은 루트 컴포넌트를 가진다
- 이것은 단지 컴포넌트 계층 구조에서 가장 위에 위치
- 하지만 Redux에서 추가로 책임져야 할 것이 존재
  - 모든 팀이 일을 하도록 하는 임무
    + 스토어를 생성
    + 무슨 리듀서 사용할지 알려주며
    + 뷰 레이어 바인딩과 뷰를 불러옴
- 애플리케이션 초기화 한 뒤로 거의 하는 일 없음
  - 화면 갱신도 신경 안씀
  - 화면 갱신은 뷰 레이어 바인딩의 도움으로 아래의 컴포넌트들이 맡아서 처리

### 어떻게 함께 동작하는가
