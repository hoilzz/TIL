# 비동기성

프로그램의 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 비동기의 핵심이다.

여러 프로그램 덩이(보통 덩이는 함수)를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 `이벤트 루프` 라는 장치가 있다.

JS 엔진은 애당초 시간이란 개념이 없다. 이 엔진은 임의의 JS 코드를 시시각각 주는대로 받아 처리하는 실행기다.
`이벤트`를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경의 몫이다.

예컨대 어떤 데이터를 서버에서 조회하려고 AJAX 요청을 할 때 함수 형태로 응답 처리 코드(콜백)를 작성하는 건
JS 엔진이 호스팅 환경에 다음과 같이 말하는 것과 같다.

"지금 잠깐 실행을 멈출 테니, 네트워크 요청이 다 끝나서 결과 데이터가 만들어지면 이 함수를 다시 불러줘!"

이후에 브라우저는 네트워크를 통해 응답을 listening 한다.

사용자에게 줄 데이터가 도착하면 콜백 함수를 이벤트 루프에 삽입하여 실행 스케줄링을 한다.

이벤트 루프는 어케 만들어졌을까?

```js
// 이벤트루프는 큐 역할을 한다. (FIFO)
var eventLoop = [];
var event;

while (true) {
  if (eventLoop.length > 0) {
    event = eventLoop.shift();
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

while 무한 루프에서 이 루프의 매 순회를 틱이라고 한다. 틱이 발생할 때 마다 큐에 적재된 이벤트를 꺼내서 실행한다.

setTimeout()은 콜백을 이벤트 루프 큐에 넣지 않는다.
setTimeout()은 타이머를 설정하는 함수다. 타이머가 끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 틱에서 콜백을 꺼내 실행한다.

이벤트 루프가 20개의 원소로 가득차면?

콜백은 기다린다. 큐의 맨 뒤에 삽입된다. (setTimeout 타이머가 완벽하게 정확한 타이밍으로 작동하지 않는 이유다.)
적어도 지정한 시간 이전에 콜백이 실행되지 않을 거란 사실은 보장할 수 있지만, 정확히 언제 혹은 좀 더 시간이 경과한 이후에 실행될지는
이벤트 루프 큐의 상황에 따라 달라진다.

---

## 동시성

무한스크롤 요청이 대표적인 동시성이다. 스크롤 바를 아래로 내리면 새로운 아이템을 요청하여 갱신된 리스트를 렌더링한다.

자바스크립트는 단일 호출 스택(Call Stack)을 사용하며, 요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리한다. 그렇다면 비동기 요청과 동시성 처리는 누가 할까? JS 엔진을 구동하는 환경, **브라우저나 Node.js** 가 담당한다.

동시성은 복수의 프로세스가 같은 시간 동안 동시에 실행됨을 의미한다. 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다. 동시성은 처리 수준 병행성과 상반되는 개념의 프로세스 수준의 병행성이라고 할 수 있다.

### 협동적 동시성

실행시간이 오래 걸리는 프로세스를 여러 단계/배치로 쪼개어 다른 동시 프로세스가 각자 작업을 이벤트 루프 큐에 인터리빙 하는 것이 목표다.

```js
var res = [];

function response(data) {
  res = res.concat(
    data.map(val => val * 2);
  )
}

ajax('http://~', response);
ajax('http://~', response);
```

응답값으로 받아오는 데이터가 천만 개라면 해당 함수 실행 중에 페이지는 그대로 멈출 것이다.

이벤트 루프 큐를 독점하지 않는, 좀 더 친화적이고 협동적이도록 각 결과를 비동기 배치로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행되도록 해야 한다.

```js
var res = [];

function response(data) {
  var chunk = data.splice(0, 1000);

  res = res.concat(
    chunk.map(val => val * 2);
  )

  if(data.length > 0) {
    setTImeout(() => response(data), 0)
  }
}

ajax('http://~', response);
ajax('http://~', response);
```

1000 개 원소를 가진 덩이 단위로 데이터 배열을 처리한다. 이렇게 하면 더 많은 프로세스를 처리해야 핟지만, 프로세스 처리 시간은 단축되므로 응답성이 좋은 사이트를 만들 수 있다.

setTimeout(..., 0)은 비동기 스케줄링 꼼수 중 하나다. "이 함수를 이벤트 루프 맨 뒤에 추가해주세요"와 같다.

### 잡

Job Queue는 이벤트 루프 큐에 새롭게 도입된 개념이다.

잡큐는 이벤트 루프 큐에서 '매 틱의 끝자락에 매달려 있는 큐'라고 생각하자.

이벤트 루프 틱 도중 발생 가능한, 비동기 특성이 내재된 액션으로 인해 새로운 이벤트가 이벤트 루프 큐에 추가되는게 아닌, 현재 틱의 잡 큐 끝 부분에 원소가 추가된다.
(비유하자면 이벤트 루프 큐는 티익스프레스 타고나서 한 번 더 타고 싶어 다시 대기열 맨 끝에서 기다리는 것, 티익스 내린 직후 대기열 맨 앞에서 곧바로 다시 타는 것)

잡은 같은 큐 끝에 더 많은 잡을 추가할 수 있는 구조다.
이론적으로는 잡 루프가 무한 반복되며 다음 이벤트 루프 틱으로 이동할 기력을 상실할 수도 있다.

잡은 setTimeout(..., 0)과 비슷하지만 처리 순서가 잘 정의되어있고 순서가 보장되는 방향이다.

```js
console.log('a');

setTimeout(function() {
  console.log('b');
}, 0);

schedule(() => {
  console.log('c');
  scheddule(() => console.log('d'));
});

// ABCD가 아닌 ACDB
```

## Summary

비동기성은 프로그램에서 '지금'과 '나중' 사이의 관계다.

실행할 이벤트가 있으면 이벤트 루프는 큐를 다 비울 때까지 실행한다.

이벤트 루프는

- while 무한 루프에서 매번 이벤트 큐를 확인한다.
- 이벤트 큐에 적재된 이벤트를 꺼내서 실행한다.
- 이벤트 큐는 FIFO로 운영된다. 그래서 setTimeout 타이머가 완벽한 타이밍에 작동하지

복수의 이벤트들은 연쇄적으로 시간에 따라 인터리빙 되며 동시에 실행 되는 것처럼 보인다.

ES6 부터는 프라미스`와 잡큐라는 항목이 추가된다. 마이크로 태스크의 개념과 다르다.

---

Q. 자바스크립트는 단일 스레드 기반 언어다. 동시에 하나의 작업만 처리할 수 있는데, 어떻게 많은 작업이 동시에 처리될까? 즉, 동시성을 어떻게 지원하는 것일까?

A. 이벤트 루프 기반의 비동기 방식을 이용한다.

Q. 이벤트 루프란?

A. JS 엔진은 단일 호출 스택(Call Stack)을 이용한다. 즉, 순차적으로 처리한다. 이 때 동시성에 대한 처리, 비동기 요청에 대한 처리는 **JS 엔진을 구동하는 환경 즉, 브라우저나 Node.js가 담당한다.**

[!img](https://image.toast.com/aaaadh/real/2018/techblog/b1493856379d11e69c16a9a4cf841567.png)

JS 엔진 밖에 Task Queue와 EventLoop이 있는 것을 확인할 수 있다. 즉, 환경 측에서 담당한다.

```js
function delay() {
  for (var i = 0; i < 100000; i++);
}
function foo() {
  delay();
  bar();
  console.log('foo!'); // (3)
}
function bar() {
  delay();
  console.log('bar!'); // (2)
}
function baz() {
  console.log('baz!'); // (4)
}

setTimeout(baz, 10); // (1)
foo();
```

`setTimeout` 함수는 브라우저에게 `타이머 이벤트`를 요청한 후 바로 스택에서 제거된다. foo가 콜스택에 쌓이고 foo에서 실행된 함수들이 쌓이고.. 모든 태스크가 종료되면 (호출 스택이 비워지면) 그 이후에 baz 함수가 콜스택에 추가되어 실행을 완료한다.

Q. setTimeout 함수를 통해 넘긴 baz 함수는 어떻게 foo 함수가 끝나자마자 실행되는가?

A. 태스크 큐는 콜백 함수들이 대기하는 큐(FIFO)다. 이벤트 루프는 호출스택이 비워질 때 마다 큐에서 콜백함수를 꺼내와서 실행하는 역할을 한다. 이러한 방식으로 setTimeout의 콜백함수가 호출스택이 비워지자마자 바로 실행될 수 있다. 태스크큐에는 DOM 조작, 유저 인터랙션(스크롤 등), 네트워킹 등이 있다.

Q. Promise와 이벤트 루프의 관계는?
A. 이벤트 루프, 태스크 큐 외에 마이크로 태스크라는 개념이 있다.

```js
setTimeout(function() {
  // (A)
  console.log('A');
}, 0);
Promise.resolve()
  .then(function() {
    // (B)
    console.log('B');
  })
  .then(function() {
    // (C)
    console.log('C');
  });
```

promise는 마이크로 태스크를 사용하는데, 태스크 큐에 대기중인 작업이 있더라도 마이크로 태스크가 먼저 실행된다. `setTimeout` 함수는 콜백 A를 태스크 큐에 추가한다. promise의 `then()`은 콜백 B를 마이크로 태스크 큐에 추가한다. 콜백 B가 먼저 실행되고 나면 `then()`의 메소드가 콜백 C를 마이크로 태스크큐에 추가한다. 이벤트 루프는 다시 마이크로 태스크를 확인하고 C를 실행한다. 다음 틱(이벤트 루프)때 마이크로 태스크 확인하고 태스크 큐의 콜백 A를 꺼내온다.

Q. micro task queue 외에 잡큐라고 들어봄?
A. 잡큐는 ES6부터 프라미스를 위해 추가된 스펙이다. HTML 스펙의 마이크로 태스크와는 별도의 개념이다.
