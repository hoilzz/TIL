# 비동기성

프로그램의 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 비동기의 핵심이다.

여러 프로그램 덩이(보통 덩이는 함수)를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 `이벤트 루프` 라는 장치가 있다.

JS 엔진은 애당초 시간이란 개념이 없다. 이 엔진은 임의의 JS 코드를 시시각각 주는대로 받아 처리하는 실행기다.
`이벤트`를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경의 몫이다.

예컨대 어떤 데이터를 서버에서 조회하려고 AJAX 요청을 할 때 함수 형태로 응답 처리 코드(콜백)를 작성하는 건
JS 엔진이 호스팅 환경에 다음과 같이 말하는 것과 같다.

"지금 잠깐 실행을 멈출 테니, 네트워크 요청이 다 끝나서 결과 데이터가 만들어지면 이 함수를 다시 불러줘!"

이후에 브라우저는 네트워크를 통해 응답을 listening 한다.

사용자에게 줄 데이터가 도착하면 콜백 함수를 이벤트 루프에 삽입하여 실행 스케줄링을 한다.

이벤트 루프는 어케 만들어졌을까?

```js
// 이벤트루프는 큐 역할을 한다. (FIFO)
var eventLoop = [];
var event;

while (true) {
  if (eventLoop.length > 0) {
    event = eventLoop.shift();
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

while 무한 루프에서 이 루프의 매 순회를 틱이라고 한다. 틱이 발생할 때 마다 큐에 적재된 이벤트를 꺼내서 실행한다.

setTimeout()은 콜백을 이벤트 루프 큐에 넣지 않는다.
setTimeout()은 타이머를 설정하는 함수다. 타이머가 끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 틱에서 콜백을 꺼내 실행한다.

이벤트 루프가 20개의 원소로 가득차면?

콜백은 기다린다. 큐의 맨 뒤에 삽입된다. (setTimeout 타이머가 완벽하게 정확한 타이밍으로 작동하지 않는 이유다.)
적어도 지정한 시간 이전에 콜백이 실행되지 않을 거란 사실은 보장할 수 있지만, 정확히 언제 혹은 좀 더 시간이 경과한 이후에 실행될지는
이벤트 루프 큐의 상황에 따라 달라진다.

---

## 동시성

무한스크롤 요청이 대표적인 동시성이다. 스크롤 바를 아래로 내리면 새로운 아이템을 요청하여 갱신된 리스트를 렌더링한다.

동시성은 복수의 프로세스가 같은 시간 동안 동시에 실행됨을 의미한다. 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다. 동시성은 처리 수준 병행성과 상반되는 개념의 프로세스 수준의 병행성이라고 할 수 있다.

### 협동적 동시성

실행시간이 오래 걸리는 프로세스를 여러 단계/배치로 쪼개어 다른 동시 프로세스가 각자 작업을 이벤트 루프 큐에 인터리빙 하는 것이 목표다.

```js
var res = [];

function response(data) {
  res = res.concat(
    data.map(val => val * 2);
  )
}

ajax('http://~', response);
ajax('http://~', response);
```

응답값으로 받아오는 데이터가 천만 개라면 해당 함수 실행 중에 페이지는 그대로 멈출 것이다.

이벤트 루프 큐를 독점하지 않는, 좀 더 친화적이고 협동적이도록 각 결과를 비동기 배치로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행되도록 해야 한다.

```js
var res = [];

function response(data) {
  var chunk = data.splice(0, 1000);

  res = res.concat(
    chunk.map(val => val * 2);
  )

  if(data.length > 0) {
    setTImeout(() => response(data), 0)
  }
}

ajax('http://~', response);
ajax('http://~', response);
```

1000 개 원소를 가진 덩이 단위로 데이터 배열을 처리한다. 이렇게 하면 더 많은 프로세스를 처리해야 핟지만, 프로세스 처리 시간은 단축되므로 응답성이 좋은 사이트를 만들 수 있다.

setTimeout(..., 0)은 비동기 스케줄링 꼼수 중 하나다. "이 함수를 이벤트 루프 맨 뒤에 추가해주세요"와 같다.

### 잡

Job Queue는 이벤트 루프 큐에 새롭게 도입된 개념이다.

잡큐는 이벤트 루프 큐에서 '매 틱의 끝자락에 매달려 있는 큐'라고 생각하자.

이벤트 루프 틱 도중 발생 가능한, 비동기 특성이 내재된 액션으로 인해 새로운 이벤트가 이벤트 루프 큐에 추가되는게 아닌, 현재 틱의 잡 큐 끝 부분에 원소가 추가된다.
(비유하자면 이벤트 루프 큐는 티익스프레스 타고나서 한 번 더 타고 싶어 다시 대기열 맨 끝에서 기다리는 것, 티익스 내린 직후 대기열 맨 앞에서 곧바로 다시 타는 것)

잡은 같은 큐 끝에 더 많은 잡을 추가할 수 있는 구조다.
이론적으로는 잡 루프가 무한 반복되며 다음 이벤트 루프 틱으로 이동할 기력을 상실할 수도 있다.

잡은 setTimeout(..., 0)과 비슷하지만 처리 순서가 잘 정의되어있고 순서가 보장되는 방향이다.

```js
console.log('a');

setTimeout(function() {
  console.log('b');
}, 0);

schedule(() => {
  console.log('c');
  scheddule(() => console.log('d'));
});

// ABCD가 아닌 ACDB
```

## Summary

비동기성은 프로그램에서 '지금'과 '나중' 사이의 관계다.

실행할 이벤트가 있으면 이벤트 루프는 큐를 다 비울 때까지 실행한다.

이벤트 루프는

- while 무한 루프에서 매번 이벤트 큐를 확인한다.
- 이벤트 큐에 적재된 이벤트를 꺼내서 실행한다.
- 이벤트 큐는 FIFO로 운영된다. 그래서 setTimeout 타이머가 완벽한 타이밍에 작동하지

복수의 이벤트들은 연쇄적으로 시간에 따라 인터리빙 되며 동시에 실행 되는 것처럼 보인다.
